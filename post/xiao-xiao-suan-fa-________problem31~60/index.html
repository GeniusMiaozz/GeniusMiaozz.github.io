<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GeniusMiao&#39;s blog.</title>
<meta name="description" content="醉梦不知天在水，满船新梦压清河。" />
<link rel="shortcut icon" href="https://geniusmiaozz.github.io/favicon.ico?v=1586875714409">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://geniusmiaozz.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://geniusmiaozz.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://geniusmiaozz.github.io/images/avatar.png?v=1586875714409" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">GeniusMiao&#39;s blog.</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E6%80%BB%E8%A7%88">题目总览</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E5%B0%8F%E8%AE%B0">题目小记</a>
<ul>
<li><a href="#31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5-%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97">31.栈的压入、弹出序列</a></li>
<li><a href="#32%E4%B8%8D%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">32.不分行从上到下打印二叉树</a></li>
<li><a href="#33%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">33.分行从上到下打印二叉树</a></li>
<li><a href="#34%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">34.之字形打印二叉树</a></li>
<li><a href="#35%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">35.二叉搜索树的后序遍历序列</a></li>
<li><a href="#36%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84">36.二叉树中和为某一值的路径</a></li>
<li><a href="#37%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">37.复杂链表的复制</a></li>
<li><a href="#38%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D">38.正则表达式的匹配</a></li>
<li><a href="#39%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">39.二叉搜索树与双向链表</a></li>
<li><a href="#40%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">40.序列化二叉树</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Homepage
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          Historical articles
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          About me
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://geniusmiaozz.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">小小算法，________(Problem31~60)</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-14 / 14 min read
        </div>
        
        <div class="post-content yue">
          <h2 id="题目总览">题目总览</h2>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">主要思想</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">栈的压入、弹出序列</td>
<td style="text-align:center">根据实例跟踪寻找规律</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center">不分行从上往下打印二叉树</td>
<td style="text-align:center">根据实例跟踪寻找规律</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:center">分行从上到下打印二叉树</td>
<td style="text-align:center">根据实例跟踪寻找规律</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td style="text-align:center">之字形打印二叉树</td>
<td style="text-align:center">根据实例跟踪寻找规律</td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td style="text-align:center">二叉搜索树的后序遍历序列</td>
<td style="text-align:center">二叉树后序遍历的方法，二叉搜索树的性质</td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td style="text-align:center">二叉树中和为某一值的路径</td>
<td style="text-align:center">根据实例跟踪寻找规律</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td style="text-align:center">复杂链表的复制</td>
<td style="text-align:center">分解简单子问题求解</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td style="text-align:center">正则表达式的匹配</td>
<td style="text-align:center">考虑多种匹配方式的不同情况</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td style="text-align:center">二叉搜索树与双向链表</td>
<td style="text-align:center">二叉树的中序遍历方法</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td style="text-align:center">序列化二叉树</td>
<td style="text-align:center">二叉树的前序遍历方法</td>
</tr>
</tbody>
</table>
<h2 id="题目小记">题目小记</h2>
<h3 id="31栈的压入-弹出序列">31.栈的压入、弹出序列</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>利用一个辅助栈来完成这个问题。定义一个指针指向弹出序列的首元素，定义一个指针指向压入序列的首元素，开始迭代求解。</p>
</li>
<li>
<p>从指向弹出序列元素的指针开始遍历弹出序列，如果当前辅助栈为空或者栈顶元素不是弹出序列中当前遍历到的元素，分两步操作：</p>
<ol>
<li>
<p>首先判断压入序列中的元素是否已经全部遍历过。如果压入序列中的元素全部遍历结束，结束迭代。</p>
</li>
<li>
<p>否则将压入序列指针当前指向的元素压入辅助栈，该指针前后移动一次，重复这个压栈-移动指针的过程，直到辅助栈中栈顶元素等于当前压入序列指针指向的元素，或压入序列中的元素全部遍历结束。</p>
</li>
</ol>
</li>
<li>
<p>此时，如果栈顶元素依然不等于弹出序列中指针当前指向的元素，则迭代结束，压入序列无法匹配弹出序列，返回 <code>False</code>；否则弹出辅助栈的栈顶元素，弹出序列中的指针向后移动一次，继续迭代过程。</p>
</li>
<li>
<p>如果在整个迭代过程中均没有匹配失败的情况，且在迭代结束之后辅助栈为空、整个弹出序列顺序遍历完成，则压入序列正确匹配弹出序列，返回 <code>True</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="32不分行从上到下打印二叉树">32.不分行从上到下打印二叉树</h3>
<ul>
<li>
<p>题目内容</p>
<p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>
</li>
<li>
<p>解题思路</p>
<p>这道题本质上就是利用队列完成一个BFS。将根节点入队列，当栈非空时，取队尾元素，该元素出队列，输出该元素的值；如果该元素的左子节点不为空，左子节点入队列；如果该右子节点不为空，右子节点入队列。</p>
</li>
</ul>
<h3 id="33分行从上到下打印二叉树">33.分行从上到下打印二叉树</h3>
<ul>
<li>
<p>题目内容</p>
<p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题基于从上到下打印二叉树小小的进行改进即可求解。定义两个变量，一个变量 <code>currentLevel</code> 代表当前层剩余打印节点的数量，初始值为 <code>1</code>；另一个变量 <code>nextLevel</code> 代表下一层节点需要打印节点的数量，初始值为 <code>0</code>。</p>
</li>
<li>
<p>每当一个节点出队列，<code>currentLevel</code> 值减一，当前层完成了一个节点的打印；如果该节点有左子节点，<code>nextLevel</code> 加一，代表下一层待打印的节点加一；如果该节点有右子节点，<code>nextLevel</code> 加一，代表下一层待打印的节点加一。</p>
</li>
<li>
<p>在每次处理完一个节点的全部打印数值相关操作后对 <code>currentLevel</code> 进行判断，如果 <code>currentLevel</code> 为 <code>0</code>，代表当前层的所有节点打印完毕，输出一个换行符；然后令 <code>currentLevel = nextLevel</code>，当前层取下一层。<code>nextLevel = 0</code>，即重新统计下一层的节点数。</p>
</li>
</ol>
</li>
</ul>
<h3 id="34之字形打印二叉树">34.之字形打印二叉树</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺 序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题依然为前一题的拓展。为了处理这种打印情况，需要两个栈。我们假设根节点所在层数为第一层。</p>
</li>
<li>
<p>在打印奇数层节点时，奇数层节点的子节点为偶数层节点，偶数层节点需要从右至左打印，根据栈的特性，应该先入栈奇数层节点的左子节点再入栈奇数层节点的右子节点。</p>
</li>
<li>
<p>在打印偶数层节点时，偶数层节点的子节点为奇数层节点，奇数层节点需要从左至右打印，根据栈的特性，应该先入栈偶数层节点的左子节点再入栈偶数层节点的右子节点。</p>
</li>
<li>
<p>根节点所在结点为第一层，首先压入奇数栈，如果奇数栈或偶数栈不为空，迭代求解。</p>
</li>
<li>
<p>在每一次打印完当前栈顶节点、当前栈弹栈并向另一个栈中压入子节点后判断当前栈是否为空，如果当前栈为空则输出一个换行符，交换两个栈，继续打印。</p>
</li>
</ol>
</li>
</ul>
<h3 id="35二叉搜索树的后序遍历序列">35.二叉搜索树的后序遍历序列</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题主要根据二叉搜索树的性质、后序遍历的原理求解，即在二叉搜索树中父节点的值大于左子节点的值且小于右子节点的值，后序遍历为左子节点、根、右子节点的顺序遍历。</p>
</li>
<li>
<p>二叉树的后序遍历序列的尾元素一定是根节点的值，首先从序列首部开始遍历，找到第一个大于根节点值的元素 <code>'a'</code>，<code>'a'</code> 元素对应的树节点一定是二叉搜索树中根节点右子树中的元素，且序列中 <code>'a'</code> 前的所有元素均为二叉搜索树中根节点左子树的元素。</p>
</li>
<li>
<p>从 <code>'a'</code> 元素开始继续向后遍历，如果遇到了一个值小于根节点的元素，则代表二叉搜索树中根节点的右子树中存在值小于根节点的元素，则这一二叉树不是二叉搜索树。</p>
</li>
<li>
<p>如果上述条件满足，则递归求解二叉搜索树的左子树序列、右子树序列，并返回两个结果的与运算值。</p>
</li>
</ol>
</li>
</ul>
<h3 id="36二叉树中和为某一值的路径">36.二叉树中和为某一值的路径</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题本质上就是二叉树的前序遍历，在前序遍历的过程中统计节点值的和进行求解。利用一个数组来保存路径，利用一个整形变量 <code>sum</code> 来保存路径中值的和。</p>
</li>
<li>
<p>从根节点开始遍历。每当扫描到一个节点，令 <code>sum</code> 加上当前结点的值，当前节点添加至数组尾部保存这一步的路径。</p>
</li>
<li>
<p>如果当前节点为叶节点，且当前的路径和 <code>sum</code> 等于目标路径和，则输出当前数组中存储的路径信息。</p>
</li>
<li>
<p>如果当前节点不是叶节点，则递归遍历它的左子节点和右子节点进行求解。</p>
</li>
<li>
<p>无论当前节点是不是叶子节点，在函数返回前都要在路径上删除当前节点、令 <code>sum</code> 减去当前结点的值，相当于路径中没有走当前节点这一步，回溯至父节点。</p>
</li>
</ol>
</li>
</ul>
<h3 id="37复杂链表的复制">37.复杂链表的复制</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复 制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling 指向链表中的任意结点或者nullptr。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这一题表面看起来较为复杂，实际化解为几个子问题之后就很简单。</p>
</li>
<li>
<p>首先完成链表中每个节点的一次复制，并在当前节点和下一节点之间插入当前节点的复制，即完成 <code>A → B → NULL</code> 到 <code>A → A' → B → B' → NULL</code> 的转换形式。</p>
</li>
<li>
<p>然后处理额外指针 <code>m_pSibling</code> 的复制，对于每一个复制得到的节点 <code>i'</code>，其额外指针 <code>m_pSibling</code> 指向原节点 <code>i</code> 的 <code>m_pSibling</code> 指向的节点的下一节点。</p>
</li>
<li>
<p>最后，完成所有复制得到的节点 <code>i'</code> 的按序连接、所有原节点 <code>i</code> 的按序连接，完成整个复杂链表的复制过程</p>
</li>
</ol>
</li>
</ul>
<h3 id="38正则表达式的匹配">38.正则表达式的匹配</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数用来匹配包含'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;及&quot;ab*a&quot;均不匹配。</p>
</li>
<li>
<p>解题思路</p>
<p>在匹配的过程中，主要进行如下几种判断：</p>
<ol>
<li>
<p>如果当前字符串与模式读到的字符均为 <code>\0</code>，则整个字符串与表达式匹配成功返回 <code>True</code>。</p>
</li>
<li>
<p>如果当前字符串读到的字符不是 <code>\0</code> 而模式读到的字符为 <code>\0</code>，代表表达式未完全匹配整个字符串，字符串与表达式匹配失败返回 <code>False</code>。</p>
</li>
<li>
<p>如果模式中当前读入字符的下一个字符为 <code>*</code>，即能匹配任意个字符，则首先判断字符串及模式中的当前读入字符是否能匹配(即两个字符相等或字符串的当前读入字符不等于 <code>\0</code> 且模式的当前读入字符为 <code>'.'</code>)。</p>
<ul>
<li>
<p>如果能匹配，则针对下一个字符 <code>'*'</code> 有三种情况：</p>
<ol>
<li>
<p>在模式上向后移动两个字符，即忽略当前读入字符与下一个字符 <code>'*'</code> 的匹配。</p>
</li>
<li>
<p>在字符串上向后移动一个字符，模式上向后移动两个字符，即当前读入字符与下一个字符 <code>'*'</code> 匹配字符串中的一个字符。</p>
</li>
<li>
<p>字符串上向后移动一个字符，模式上向后移动零个字符，即当前读入字符与下一个字符 <code>'*'</code> 匹配字符串中的若干个字符。</p>
</li>
</ol>
</li>
<li>
<p>如果不能匹配，则针对下一个字符 <code>'*'</code> 只有一种情况：在模式上向后移动两个字符，即忽略当前读入字符与下一个字符 <code>'*'</code> 的匹配。</p>
</li>
</ul>
</li>
<li>
<p>如果模式中当前读入字符的下一个字符不是 <code>*</code>，则判断字符串及模式中的当前读入字符是否能匹配(即两个字符相等或字符串的当前读入字符不等于 <code>\0</code> 且模式的当前读入字符为 <code>'.'</code>)。如果匹配，则字符串上向后移动一个字符，模式上向后移动一个字符继续匹配。</p>
</li>
<li>
<p>所有其他情况均返回 <code>False</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="39二叉搜索树与双向链表">39.二叉搜索树与双向链表</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题本质上就是二叉树的中序遍历过程。假设双向链表从头结点开始值递增连接，在将二叉搜索树转换为双向链表时，定义每个树节点的左子节点指针调整为链表中指向前一个节点的指针，每个树节点右子节点的指针调整为指向后一个节点的指针。</p>
</li>
<li>
<p>定义双向链表的头结点的前一节点指针为空指针，尾结点的后一节点指针为空指针。</p>
</li>
<li>
<p>从二叉搜索树的根节点开始遍历，如果遍历过程中扫描到的节点为空指针，返回；否则取当前扫描到的节点 <code>pCurrent</code>。</p>
</li>
<li>
<p>如果当前扫描到的节点 <code>pCurrent</code> 左子节点不为空，首先递归带入当前节点 <code>pCurrent</code> 的左子节点进行求解。</p>
</li>
<li>
<p>当前节点 <code>pCurrent</code> 的左子节点指针指向双向链表的头结点。（当遍历到二叉搜索树的最左子节点时，这一节点为树中值最小的节点，也是未来双向链表的头结点。由于这一节点左子节点为空，会跳过前一步的递归求解左子节点操作，直接进行本步操作，此时实际操作为令这一节点的左子节点、即双向链表中的前一节点指针指向空，完成了双向链表中头结点的前一节点指针为空指针的操作）。</p>
</li>
<li>
<p>如果当前双向链表的指针不为空指针，则令双向链表指针的右指针指向当前节点 <code>pCurrent</code> （当遍历到二叉搜索树的最左子节点时，这一节点为树中值最小的节点，也是未来双向链表的头结点。由于当前节点的左子节点为空，也就不会有某个节点的右子节点指针、即下一节点的指针指向当前节点了，此时双向链表的头结点就是这一“为空的左子节点”，故需要继续一次判断）。</p>
</li>
<li>
<p>双向链表的头结点取当前节点 <code>pCurrent</code>。</p>
</li>
<li>
<p>如果当前节点 <code>pCurrent</code> 的右子节点不为空，归带入当前节点 <code>pCurrent</code> 的右子节点进行求解。</p>
</li>
</ol>
</li>
</ul>
<h3 id="40序列化二叉树">40.序列化二叉树</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道体本质上就是二叉树的前序遍历过程，在前序遍历过程中进行求解。</p>
</li>
<li>
<p>对于序列化二叉树，从根节点开始前序遍历。在前序遍历过程中如果遇到空节点就在序列尾部插入对应的空指针标识符并返回，否则在序列尾部插入当前节点的值，然后递归遍历当前节点的左子节点、右子节点进行求解。</p>
</li>
<li>
<p>对于反序列化二叉树，从序列的首部开始遍历。如果当前扫描到的元素为空节点标识符，则当前节点为空指针并返回，否则将当前扫描到的元素的值赋值给当前节点的值，扫描序列的下一个元素，递归带入当前节点的左子节点、当前节点的右子节点进行求解。</p>
</li>
</ol>
</li>
</ul>

        </div>

        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://geniusmiaozz.github.io/post/ccfu-xi/">
                <h3 class="post-title">
                  C/C++复习总结
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'd666ec54fdd7e7bcf5a5',
    clientSecret: 'eb4829aff529a141e142de8a677d7b34925325a6',
    repo: 'geniusmiaozz.github.io',
    owner: 'GeniusMiaozz',
    admin: ['GeniusMiaozz'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://geniusmiaozz.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
