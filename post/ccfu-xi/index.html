<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GeniusMiao&#39;s blog.</title>
<meta name="description" content="醉梦不知天在水，满船新梦压清河。" />
<link rel="shortcut icon" href="https://geniusmiaozz.github.io/favicon.ico?v=1586868733047">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://geniusmiaozz.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://geniusmiaozz.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://geniusmiaozz.github.io/images/avatar.png?v=1586868733047" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">GeniusMiao&#39;s blog.</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#cc%E5%A4%8D%E4%B9%A0">C/C++复习</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B">基础数据/结构/类型</a>
<ul>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">内置类型</a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">局部变量与全局变量</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E7%B1%BB">存储类</a></li>
<li><a href="#%E4%BD%8D%E5%9F%9F">位域</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3">内存相关</a>
<ul>
<li><a href="#%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8">指针 &amp; 引用</a>
<ul>
<li><a href="#%E6%8C%87%E9%92%88">指针</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%82%E5%90%8C%E7%82%B9">指针与引用和异同点</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">内存分配</a></li>
<li><a href="#c-%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><code>C</code> 中的动态内存分配</a></li>
<li><a href="#c-%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-2"><code>C++</code> 中的动态内存分配</a></li>
<li><a href="#mallocfree%E4%B8%8Enewdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><code>malloc/free与new/delete</code> 的区别</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3">函数相关</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F">函数参数的压栈顺序</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">处理函数返回值</a></li>
<li><a href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调函数</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3">面向对象相关</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">对象的定义</a></li>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1">抽象</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">对象内存布局</a></li>
<li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">析构函数</a></li>
<li><a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">拷贝构造函数</a></li>
<li><a href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">友元函数</a></li>
<li><a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">内联函数</a></li>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0">虚函数 &amp; 纯虚函数</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">类的静态成员</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E8%A1%A5%E9%BD%90">内存补齐</a></li>
<li><a href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%8D%E7%BD%AEconst%E4%B8%8E%E5%90%8E%E7%BD%AEconst">类成员函数的前置<code>const</code>与后置<code>const</code></a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a>
<ul>
<li><a href="#%E9%A2%84%E5%A4%84%E7%90%86">预处理</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li>
</ul>
</li>
<li><a href="#cc-%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><code>C/C++</code> 中的关键字</a>
<ul>
<li><a href="#null-%E5%92%8C-nullptr"><code>NULL</code> 和 <code>nullptr</code></a></li>
<li><a href="#delete-%E5%92%8C-delete"><code>delete[]</code> 和 <code>delete</code></a></li>
<li><a href="#xx_ptr%E5%9B%9B%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><code>[xx]_ptr</code>四种智能指针</a>
<ul>
<li><a href="#auto_ptr">auto_ptr</a></li>
<li><a href="#unique_ptr">unique_ptr</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
<li><a href="#weak_ptr">weak_ptr</a></li>
</ul>
</li>
<li><a href="#xx_cast%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2"><code>[xx]_cast</code>四种转换</a>
<ul>
<li><a href="#static_cast"><code>static_cast</code></a></li>
<li><a href="#const_cast"><code>const_cast</code></a></li>
<li><a href="#dynamic_cast"><code>dynamic_cast</code></a></li>
<li><a href="#reinterpret_cast"><code>reinterpret_cast</code></a></li>
</ul>
</li>
<li><a href="#auto"><code>auto</code></a></li>
<li><a href="#regiter"><code>regiter</code></a></li>
<li><a href="#static"><code>static</code></a></li>
<li><a href="#extern"><code>extern</code></a></li>
<li><a href="#stdout-stderr"><code>stdout</code> &amp; <code>stderr</code></a></li>
<li><a href="#size_t"><code>size_t</code></a></li>
</ul>
</li>
<li><a href="#cc-%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><code>C/C++</code> 中的内置函数</a>
<ul>
<li><a href="#sizeof"><code>sizeof()</code></a></li>
<li><a href="#assert-int-expression"><code>assert( int expression )</code></a></li>
</ul>
</li>
<li><a href="#stl-%E7%9B%B8%E5%85%B3"><code>STL</code> 相关</a>
<ul>
<li><a href="#vector"><code>vector</code></a></li>
<li><a href="#list"><code>list</code></a></li>
<li><a href="#set"><code>set</code></a></li>
<li><a href="#map"><code>map</code></a></li>
<li><a href="#unordered_map"><code>unordered_map</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Homepage
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          Historical articles
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          About me
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://geniusmiaozz.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">C/C++复习总结</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-07 / 27 min read
        </div>
        
        <div class="post-content yue">
          <h1 id="cc复习">C/C++复习</h1>
<h2 id="基础数据结构类型">基础数据/结构/类型</h2>
<h3 id="常量">常量</h3>
<ul>
<li>
<p>整数常量：前缀 <code>0X</code> 或 <code>0x</code> 代表十六进制，前缀 <code>0</code> 表示八进制，不带前缀默认为十进制；后缀 <code>U/u</code> 代表无符号整数，<code>L/l</code> 代表长整数。</p>
</li>
<li>
<p>字符常量：<code>\a</code> 为警报铃声，<code>\b</code> 为退格键，<code>\f</code> 为换页符，<code>\v</code> 为垂直制表符，<code>\ooo</code> 为一到三位的八进制数，<code>\xhhh</code> ......为一道多个数字的十六进制数。</p>
</li>
<li>
<p>对于常量的定义，多推荐为大写字母的形式。</p>
</li>
</ul>
<h3 id="内置类型">内置类型</h3>
<ul>
<li>
<p>各种变量类型在内存中存储值时需要占用的位数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>4</code></td>
</tr>
<tr>
<td style="text-align:center"><code>short int</code></td>
<td style="text-align:center"><code>2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long int</code></td>
<td style="text-align:center"><code>8</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>4</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>8</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center"><code>16</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="局部变量与全局变量">局部变量与全局变量</h3>
<ul>
<li>
<p>当局部变量被定义时，系统不会对其初始化。定义全局变量时，会自动初始化为下列值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">初始化默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>'\0'</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pointer</code></td>
<td style="text-align:center"><code>NULL</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="浮点数">浮点数</h3>
<ul>
<li>浮点数的比较不能直接使用 <code>'='</code> 进行判断，可以使用减法，当差值在精度允许范围内（比如 <code>0.0000001</code>）即可视为两个浮点数相等。</li>
</ul>
<h3 id="字符串">字符串</h3>
<ul>
<li>对于<code>char str1[]</code> 和 <code>char str2[]</code>，如果二者赋值相同，由于 <code>str1</code> 和 <code>str2</code> 初始地址不同，<code>str1 != str2</code>；对于<code>char *str1</code> 和 <code>char *str2</code>，如果二者赋值相同，相当于二者指向内存中同一段地址，<code>str1 = str2</code>。</li>
</ul>
<h3 id="存储类">存储类</h3>
<ul>
<li>存储类定义 <code>C/C++</code> 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。</li>
</ul>
<h3 id="位域">位域</h3>
<ul>
<li>位域在本质上就是一种结构体类型，只不过其成员按二进制中的每一位分配。</li>
</ul>
<h2 id="内存相关">内存相关</h2>
<h3 id="指针-引用">指针 &amp; 引用</h3>
<h4 id="指针">指针</h4>
<ul>
<li>
<p><code>32</code> 位机器一个指针占 <code>4</code> 字节空间，<code>64</code> 位机器一个指针占 <code>8</code> 字节空间。</p>
</li>
<li>
<p>野指针是指向一个已删除的对象或者未申请访问受限内存区域的指针。</p>
</li>
<li>
<p>数组做为函数的参数传递时，自动退化为同类型指针，指向数组的第一个元素。</p>
</li>
<li>
<p>指针函数：返回值是某一类型指针的函数，如 <code>int *fun()</code>，该函数返回值为一个地址；函数指针：指向某一函数的指针变量可以调用函数，如 <code>int (*fun)() = &amp; fun1</code>。</p>
</li>
<li>
<p>指针数组：一个元素均为某一类型指针的的数组，如 <code>int *p[10]</code>，该数组包含是个 <code>int</code> 类型指针的元素；数组指针：指向数组某个元素地址的指针，如 <code>int (*p) [10]</code>，<code>p</code>指向数组的首地址（首个元素的地址）。</p>
</li>
<li>
<p>智能指针：主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。</p>
</li>
</ul>
<h4 id="引用">引用</h4>
<ul>
<li>
<p>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</p>
</li>
<li>
<p>引用必须在创建时被初始化。指针可以在任何时间被初始化。</p>
</li>
<li>
<p>引用一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率。</p>
</li>
</ul>
<h4 id="指针与引用和异同点">指针与引用和异同点</h4>
<ul>
<li>
<p>区别总结：</p>
<ol>
<li>
<p>指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li>
<p>使用 <code>sizeof</code> 求得的是指针的大小，而引用则是被引用对象的大小；</p>
</li>
<li>
<p>指针可以被初始化为 <code>NULL</code>，而引用必须被初始化且必须是一个已有对象的引用；</p>
</li>
<li>
<p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
</li>
<li>
<p>可以有 <code>const</code>指针，但是没有 <code>const</code> 引用；</p>
</li>
<li>
<p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p>
</li>
<li>
<p>指针可以有多级指针（<code>**p</code>），而引用至于一级；</p>
</li>
<li>
<p>指针和引用使用 <code>++</code> 运算符的意义不一样；</p>
</li>
<li>
<p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
</li>
</ol>
</li>
<li>
<p>指针与引用可以参考如下代码：</p>
<pre><code class="language-C++">int a,b,*p,&amp;r=a;//正确
r = 3;//正确：等价于a=3
int &amp;rr;//出错：引用必须初始化
p = &amp;a;//正确：p中存储a的地址，即p指向a
*p = 4;//正确：p中存的是a的地址，对a所对应的存储空间存入值4
p = &amp;b//正确：p可以多次赋值，p存储b的地址
</code></pre>
</li>
</ul>
<h3 id="内存分配">内存分配</h3>
<ul>
<li>
<p>自上而下为最低内存地址至最高内存地址：</p>
<table>
<thead>
<tr>
<th style="text-align:center">区域</th>
<th style="text-align:center">存放内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">保留区</td>
<td style="text-align:center">系统保留区域</td>
</tr>
<tr>
<td style="text-align:center">程序代码区</td>
<td style="text-align:center">函数代码块的二进制代码，只读</td>
</tr>
<tr>
<td style="text-align:center">常量区</td>
<td style="text-align:center">一般常量、字符串常量，只读</td>
</tr>
<tr>
<td style="text-align:center">全局数据区</td>
<td style="text-align:center">全局变量、静态变量，可读写</td>
</tr>
<tr>
<td style="text-align:center">堆区</td>
<td style="text-align:center">动态分配的数据</td>
</tr>
<tr>
<td style="text-align:center">未被分配的内存</td>
<td style="text-align:center">堆的增长区</td>
</tr>
<tr>
<td style="text-align:center">映射区</td>
<td style="text-align:center">存储动态链接库</td>
</tr>
<tr>
<td style="text-align:center">未被分配的内存</td>
<td style="text-align:center">栈的增长区</td>
</tr>
<tr>
<td style="text-align:center">栈区</td>
<td style="text-align:center">局部变量</td>
</tr>
<tr>
<td style="text-align:center">命令行参数区</td>
<td style="text-align:center">命令行参数和编辑变量</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="c-中的动态内存分配"><code>C</code> 中的动态内存分配</h3>
<ul>
<li>
<p>可以利用四种方法进行动态内存操作：</p>
<ol>
<li>
<p><code>void *calloc(int num, int size)</code>：在内存中动态地分配 <code>num</code> 个长度为 <code>size</code> 的连续空间，并将每一个字节都初始化为<code>0</code>。所以它的结果是分配了 <code>num * size</code> 个字节长度的内存空间，并且每个字节的值都是 <code>0</code> 。</p>
</li>
<li>
<p><code>void free(void *address)</code>：该函数释放 <code>address</code> 所指向的内存块,释放的是动态分配的内存空间。</p>
</li>
<li>
<p><code>void *malloc(int num)</code>:在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</p>
</li>
<li>
<p><code>void *realloc(void address, int newsize)</code>：该函数重新分配内存，把内存扩展到 <code>newsize</code>。</p>
</li>
<li>
<p><code>void *memset(void *s, int ch, size_t n)</code>：将 <code>s</code> 中当前位置后面的 <code>n</code> 个字节用 <code>ch</code> 替换并返回s。</p>
</li>
</ol>
</li>
</ul>
<h3 id="c-中的动态内存分配-2"><code>C++</code> 中的动态内存分配</h3>
<ul>
<li>
<p>使用 <code>new &lt;data_type&gt;</code> 来在分配内存的同时创建一个对象，使用 <code>delete &lt;data_name&gt;</code> 来删除分配的内存。</p>
</li>
<li>
<p>对于内置类型而言，<code>new</code> 仅仅是分配内存，除非后面显示加 <code>()</code>，相当于调用它的构造函数，对于自定义类型而言，只要一调用 <code>new</code>，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化，即使后面没有加 <code>()</code>。</p>
</li>
</ul>
<h3 id="mallocfree与newdelete-的区别"><code>malloc/free与new/delete</code> 的区别</h3>
<ul>
<li>
<p>相同点：都可用于申请动态内存和释放内存。</p>
</li>
<li>
<p>不同点：</p>
<ol>
<li>
<p><code>malloc</code> 与 <code>free</code> 是 <code>C</code> 语言的标准库函数，<code>new/delete</code> 是 <code>C++</code> 的操作符。</p>
</li>
<li>
<p><code>malloc</code> 需要给定申请内存的大小，返回的指针需要强制转换；<code>new</code> 不仅无需指定内存大小并申请一块内存，还会调用类的构造函数生成对象，返回的指针不需要强制转换。</p>
</li>
<li>
<p><code>free</code> 只是释放一块内存区域，<code>del</code> 在释放内存区域的同时还对调用类的析构函数。</p>
</li>
<li>
<p><code>malloc</code> 失败返回空，<code>new</code> 失败抛异常。</p>
</li>
</ol>
</li>
</ul>
<h2 id="函数相关">函数相关</h2>
<h3 id="函数参数的压栈顺序">函数参数的压栈顺序</h3>
<ul>
<li>从右到左。</li>
</ul>
<h3 id="处理函数返回值">处理函数返回值</h3>
<ul>
<li>在函数返回时会生成一个临时变量来保存返回值结果，把函数返回值的引用作为函数参数传入函数内。</li>
</ul>
<h3 id="回调函数">回调函数</h3>
<ul>
<li>
<p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
</li>
<li>
<p>简单来说：回调函数是由别人的函数执行时调用你实现的函数。</p>
</li>
<li>
<p>一个回调函数的通俗解释，源于<a href="https://www.zhihu.com/answer/13005983">知乎回答</a>：你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</li>
</ul>
<h2 id="面向对象相关">面向对象相关</h2>
<h3 id="对象的定义">对象的定义</h3>
<ul>
<li>对象是指一块能存储数据并具有某种类型的内存空间。</li>
</ul>
<h3 id="封装">封装</h3>
<ul>
<li>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。</li>
</ul>
<h3 id="抽象">抽象</h3>
<ul>
<li>
<p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
</li>
<li>
<p>数据抽象有两个重要的优势：</p>
<ol>
<li>
<p>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</p>
</li>
<li>
<p>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</p>
</li>
</ol>
</li>
<li>
<p>设计策略：抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。</p>
</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li>
<p>三种继承方式相应地改变了基类成员的访问属性，如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">继承方式</th>
<th style="text-align:center">基类 <code>public</code> 成员、<code>protected</code> 成员、<code>private</code> 成员变化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>public</code> 继承</td>
<td style="text-align:center"><code>public, protected, private</code></td>
</tr>
<tr>
<td style="text-align:center"><code>private</code> 继承</td>
<td style="text-align:center"><code>private, private, private</code></td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code> 继承</td>
<td style="text-align:center"><code>protected, protected, private</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>派生类会继承所有基类方法，但下列情况除外：</p>
<ol>
<li>
<p>基类的构造函数、析构函数和拷贝构造函数。</p>
</li>
<li>
<p>基类的重载运算符。</p>
</li>
<li>
<p>基类的友元函数。</p>
</li>
</ol>
</li>
<li>
<p>假设一个类 <code>C</code> 分别被类 <code>A</code> 和类 <code>B</code> 继承，需要设置继承方式为虚继承，否则会使 <code>D</code> 创建两个对象。</p>
</li>
</ul>
<h3 id="多态">多态</h3>
<ul>
<li>
<p>多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
</li>
<li>
<p>多态的实现主要分为静态多态和动态多态。</p>
<ol>
<li>
<p>静态多态主要是重载，在编译的时候就已经确定。两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中.</p>
</li>
<li>
<p>动态多态是用虚函数机制实现的，在运行期间动态绑定，通过在基类中对函数使用关键字 <code>virtual</code> 声明为虚函数来实现。子类继承了父类，父类中的函数是虚函数，在子类中重写了这个虚函数，这种情况会使编译器在处理派生类中重新定义的该函数时不会静态链接到基类的该函数。这种操作称为动态链接，或后期绑定。</p>
</li>
</ol>
</li>
<li>
<p>如果基类中声明虚函数时不进行定义而是进行 <code>virtual &lt;type&gt; &lt;fun()&gt; = 0</code> 的操作，这样就会声明为纯虚函数。通常在处理基类中不能对虚函数给出有意义的实现情况时使用。</p>
</li>
</ul>
<h3 id="抽象类">抽象类</h3>
<ul>
<li>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p>
</li>
<li>
<p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p>
</li>
</ul>
<h3 id="对象内存布局">对象内存布局</h3>
<ul>
<li>
<p>最基本的对象内存计算规则：对象的内存大小为成员变量的内存之和，成员函数不占内存，无成员变量的对象大小为 <code>1</code> 字节。</p>
</li>
<li>
<p>对于一个只包含非静态成员变量和普通成员函数的类，成员函数放在代码区，该类所有对象公有这一个；成员变量放在堆区，该类对象私有，每新建一个对象都回新建一块内存区域。</p>
</li>
<li>
<p>当有类中有虚函数时，会为该类的每一个实例在堆区添加一个指向虚函数表的指针。</p>
</li>
<li>
<p>类中的 <code>static</code> 成员变量不占用内存该类自身实例化对象的内存。</p>
</li>
</ul>
<h3 id="析构函数">析构函数</h3>
<ul>
<li>
<p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>
</li>
<li>
<p>类析构顺序：</p>
<ol>
<li>
<p>派生类本身的析构函数。</p>
</li>
<li>
<p>基类析构函数。</p>
</li>
</ol>
</li>
</ul>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<ul>
<li>
<p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<ol>
<li>
<p>通过使用另一个同类型的对象来初始化新创建的对象。</p>
</li>
<li>
<p>复制对象把它作为参数传递给函数。</p>
</li>
<li>
<p>复制对象，并从函数返回这个对象。</p>
</li>
</ol>
</li>
<li>
<p>如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。</p>
</li>
<li>
<p>拷贝构造函数的形参必须设为常量的引用，否则会引起拷贝构造函数的无限调用。</p>
</li>
</ul>
<h3 id="友元函数">友元函数</h3>
<ul>
<li>
<p>类的友元函数是定义在类外部，但有权访问类的所有私有（<code>private</code>）成员和保护（<code>protected</code>）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
</li>
<li>
<p>友元函数没有 <code>this</code> 指针，因为友元不是类的成员。只有成员函数才有 <code>this</code> 指针。</p>
</li>
<li>
<p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <code>friend</code>。</p>
</li>
<li>
<p>如果要声明 <code>B</code> 类为 <code>A</code> 类的右元，即 <code>B</code> 的所有成员函数可以访问 <code>A</code> 类中的私有成员及保护成员，需要在 <code>A</code> 类中声明：</p>
<pre><code class="language-C++">friend class B
</code></pre>
</li>
</ul>
<h3 id="内联函数">内联函数</h3>
<ul>
<li>
<p>内联函数在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
</li>
<li>
<p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
</li>
<li>
<p>引入内联函数的目的是为了解决程序中函数调用的效率问题。程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这是以额外空间换取时间上节省。</p>
</li>
<li>
<p>使用内联函数注意三点：</p>
<ol>
<li>
<p>在内联函数内不允许使用循环语句和开关语句</p>
</li>
<li>
<p>内联函数的定义必须出现在内联函数第一次调用之前。</p>
</li>
<li>
<p>类结构中所在的类说明内部定义的函数是内联函数。</p>
</li>
</ol>
</li>
</ul>
<h3 id="虚函数-纯虚函数">虚函数 &amp; 纯虚函数</h3>
<ul>
<li>
<p>虚函数讲解：<a href="https://zhuanlan.zhihu.com/p/28530472">知乎文章</a></p>
</li>
<li>
<p>通过对象内存最开始位置的虚函数表指针 <code>vptr</code> 找到虚函数表 <code>vtbl</code>，表中存放着虚函数的指针，通过该指针找到对应虚函数的实现区域并进行调用。</p>
</li>
<li>
<p>构造函数不可以是虚函数，析构函数可以是虚函数且推荐设置为虚函数。</p>
</li>
<li>
<p>虚函数可以声明为 <code>private</code>, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的 <code>private</code> 虚函数。虚函数的重载性和它声明的权限无关。</p>
</li>
<li>
<p>声明了纯虚函数的类是一个抽象类，无法创建该类的实例，只能创建该类的派生类的实例。</p>
</li>
<li>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
</li>
<li>
<p>纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。</p>
</li>
</ul>
<h3 id="类的静态成员">类的静态成员</h3>
<ul>
<li>
<p>无论创建多少个该类的对象，该类的静态成员都只有一个副本。</p>
</li>
<li>
<p>类的静态成员在类的外部通过使用范围解析运算符 <code>::</code> 来重新声明静态变量从而对它进行初始化。</p>
</li>
<li>
<p>静态成员函数即使在类对象不存在的情况下也能被调用。</p>
</li>
<li>
<p>静态成员函数没有 <code>this</code> 指针只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p>
</li>
</ul>
<h3 id="内存补齐">内存补齐</h3>
<ul>
<li>
<p>内存补齐讲解：<a href="https://zhuanlan.zhihu.com/p/32261819">知乎文章</a></p>
</li>
<li>
<p>内存补齐主要遵循两条基本规则：</p>
<ol>
<li>
<p>成员变量的偏移量必须为该变量自身大小的整数倍；</p>
</li>
<li>
<p>对象内存的大小为最大成员变量大小的整数倍；</p>
</li>
</ol>
</li>
<li>
<p>宏 <code>#pragma pack (n)</code> 可以强制设定偏移量为 <code>n</code> 或自身内存大小中较小值的整数倍，<code>n</code> 为 <code>1</code> 时即设置为无内存补齐。</p>
</li>
</ul>
<h3 id="类成员函数的前置const与后置const">类成员函数的前置<code>const</code>与后置<code>const</code></h3>
<ul>
<li>
<p>当 <code>const</code> 在函数名前面的时候修饰的是函数返回值，函数返回一个常量值。</p>
</li>
<li>
<p>当 <code>const</code> 在函数名后面的输给表示是该类的常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作；对于该类的 <code>const</code> 的对象，不能引用非 <code>const</code> 的成员函数（只能引用后置 <code>const</code> 修饰的常成员函数）。</p>
</li>
</ul>
<h2 id="其它">其它</h2>
<h3 id="预处理">预处理</h3>
<ul>
<li>
<p><code>ANSI C</code>预定义了一些宏可以直接使用但不可以修改，包括：</p>
<ol>
<li>
<p><code>\_\_DATE\_\_</code>：当前日期，一个以 <code>&quot;MMM DD YYYY&quot;</code> 格式表示的字符常量。</p>
</li>
<li>
<p><code>\_\_TIME\_\_</code>：当前时间，一个以 <code>&quot;HH:MM:SS&quot;</code> 格式表示的字符常量。</p>
</li>
<li>
<p><code>\_\_FILE\_\_</code>：这会包含当前文件名，一个字符串常量。</p>
</li>
<li>
<p><code>\_\_LINE\_\_</code>：这会包含当前行号，一个十进制常量。</p>
</li>
<li>
<p><code>\_\_STDC\_\_</code>：当编译器以 <code>ANSI</code> 标准编译时，则定义为 <code>1</code>。</p>
</li>
</ol>
</li>
<li>
<p>预处理器运算符</p>
<ol>
<li>
<p>宏延续运算符（<code>\</code>）：一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（<code>\</code>）。</p>
</li>
<li>
<p>字符串常量化运算符（<code>#</code>）：在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（<code>#</code>）。在宏中使用的该运算符有一个特定的参数或参数列表。</p>
</li>
<li>
<p>标记粘贴运算符（<code>##</code>）：宏定义内的标记粘贴运算符（<code>##</code>）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。</p>
</li>
<li>
<p><code>defined()</code> 运算符：预处理器 <code>defined</code> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 <code>#define</code> 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。</p>
</li>
</ol>
</li>
</ul>
<h3 id="异常处理">异常处理</h3>
<ul>
<li>
<p>异常是程序在执行期间产生的问题。<code>C++</code> 异常处理涉及到三个关键字：</p>
<ol>
<li>
<p><code>throw</code>: 当问题出现时，程序会抛出一个异常。这是通过使用 <code>throw</code> 关键字来完成的。</p>
</li>
<li>
<p><code>catch</code>: 在您想要处理问题的地方，通过异常处理程序捕获异常。<code>catch</code> 关键字用于捕获异常。</p>
</li>
<li>
<p><code>try</code>: <code>try</code> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 <code>catch</code> 块。</p>
</li>
</ol>
</li>
</ul>
<h2 id="cc-中的关键字"><code>C/C++</code> 中的关键字</h2>
<h3 id="null-和-nullptr"><code>NULL</code> 和 <code>nullptr</code></h3>
<ul>
<li>在编译时 NULL 会被解释为 0 ，而 <code>nullptr</code> 就代表空指针。</li>
</ul>
<h3 id="delete-和-delete"><code>delete[]</code> 和 <code>delete</code></h3>
<ul>
<li>
<p>区别讲解：<a href="https://blog.csdn.net/u012936940/article/details/80919880">CSDN文章</a></p>
</li>
<li>
<p>概括的为：对于基本数据类型（如 <code>int</code>）二者无差别，对于自定义类型（通常指类）如果是 <code>new</code> 申请的内存，释放时用 <code>delete</code>；如果是使用 <code>new []</code> 申请的内存，释放时要用 <code>delete []</code>。</p>
</li>
</ul>
<h3 id="xx_ptr四种智能指针"><code>[xx]_ptr</code>四种智能指针</h3>
<h4 id="auto_ptr">auto_ptr</h4>
<ul>
<li>
<p>采用所有权模式，存在潜在的内存崩溃问题，于 <code>C++11</code> 中被抛弃。例如如下代码：</p>
<pre><code class="language-C++">auto_ptr&lt;string&gt; p1 (new string (&quot;Hello&quot;));
auto_ptr&lt;string&gt; p2;
p2 = p1; //auto_ptr不会报错
</code></pre>
<p>当程序运行时访问 <code>p1</code> 将会报错，因为 <code>p2</code> 剥夺了 <code>p1</code> 的所有权。</p>
</li>
</ul>
<h4 id="unique_ptr">unique_ptr</h4>
<ul>
<li>
<p>实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象，同时还有更智能的功能，比 <code>auto_ptr</code> 更安全，替代了 <code>auto_ptr</code>。针对于代码：</p>
<pre><code class="language-C++">uqinue_ptr&lt;string&gt; p1(new string (&quot;Hello&quot;));
unique_ptr&lt;string&gt; p2;
p2 = p1; //报错！避免p3不再指向有效数据的问题
p2 = move(ps1); // 正确！
p3 = unique_ptr&lt;string&gt;(new string (&quot;World&quot;)); // 正确！右值为临时值。
</code></pre>
</li>
</ul>
<h4 id="shared_ptr">shared_ptr</h4>
<ul>
<li>实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。它使用计数机制来表明资源被几个指针共享，当计数等于 <code>0</code> 时，资源会被释放。</li>
</ul>
<h4 id="weak_ptr">weak_ptr</h4>
<ul>
<li><code>weak_ptr</code> 是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象. 进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code>。 <code>weak_ptr</code> 只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 工作, 它只可以从一个 <code>shared_ptr</code> 或另一个 <code>weak_ptr</code> 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</li>
</ul>
<h3 id="xx_cast四种转换"><code>[xx]_cast</code>四种转换</h3>
<ul>
<li>讲解：<a href="https://www.jianshu.com/p/5163a2678171">简书文章</a></li>
</ul>
<h4 id="static_cast"><code>static_cast</code></h4>
<ul>
<li>
<p>主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：</p>
<ol>
<li>
<p>用于类层次结构中，基类和子类之间指针和引用的转换；</p>
<p>当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；</p>
<p>当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；</p>
</li>
<li>
<p>用于基本数据类型之间的转换，如把 <code>int</code> 转换成 <code>char</code>，把 <code>int</code> 转换成<code>enum</code> 等等，这种转换的安全性需要程序员来保证；</p>
</li>
<li>
<p>把 <code>void</code> 指针转换成目标类型的指针，是及其不安全的；</p>
</li>
</ol>
</li>
<li>
<p><code>static_cast</code> 不能转换掉 <code>expression</code> 的 <code>const</code>、<code>volatile</code> 和<code>__unaligned</code> 属性。</p>
</li>
</ul>
<h4 id="const_cast"><code>const_cast</code></h4>
<ul>
<li>用于将 <code>const</code> 属性转为非 <code>const</code> 属性。</li>
</ul>
<h4 id="dynamic_cast"><code>dynamic_cast</code></h4>
<ul>
<li>
<p><code>dynamic_cast</code> 主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换，只能用于含有虚函数的类间的转换，且只能转换为类的指针、类的引用或是 <code>void*</code>。</p>
</li>
<li>
<p>在类层次间进行上行转换时，与 <code>static_cast</code> 效果一样；在进行类层次间的下行转换时，会检查基类的指针是否真正的指向一个子类类型的对象，如果是则能进行正确的转换，否则会返回 <code>NULL</code>，如果是引用则会在运行时抛出异常。一段应用代码：</p>
<pre><code class="language-C++">//定义
class Widget{};
class SpecialWidget:public Widget{};
void update(SpecialWidget  *psw);

Widget * pw;

//如果pw所指的是SpecialWidget ，那么就传递过去；如果pw指的是Widget ，
//那么传递过去的值是null
update(dynamic_cast&lt;SpecialWidget  *&gt; (pw));
</code></pre>
</li>
</ul>
<h4 id="reinterpret_cast"><code>reinterpret_cast</code></h4>
<ul>
<li>几乎什么都可以转，故可能会出问题，尽量少用。</li>
</ul>
<h3 id="auto"><code>auto</code></h3>
<ul>
<li>
<p><code>auto</code> 是所有局部变量默认的存储类。<code>auto</code> 只能用在函数内，即 <code>auto</code> 只能修饰局部变量。</p>
</li>
<li>
<p>从 <code>C++ 17</code> 开始，<code>auto</code> 关键字不再是 <code>C++</code> 存储类说明符。</p>
</li>
</ul>
<h3 id="regiter"><code>regiter</code></h3>
<ul>
<li>
<p><code>register</code> 用于定义存储在寄存器中而不是 <code>RAM</code> 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 <code>'&amp;'</code> 运算符（因为它没有内存位置）。</p>
</li>
<li>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 <code>'register'</code> 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
</li>
<li>
<p>从 <code>C++ 17</code> 开始，<code>register</code> 关键字被弃用。</p>
</li>
</ul>
<h3 id="static"><code>static</code></h3>
<ul>
<li>
<p><code>static</code> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。即当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。因此，使用 <code>static</code> 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
</li>
<li>
<p><code>static</code> 修饰符可以应用于全局变量。当 <code>static</code> 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 <code>static</code> 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 <code>static</code> 变量或方法同一个文件中。</p>
</li>
<li>
<p>在函数返回类型前加static，函数就定义为静态函数，这个函数只可在本 <code>cpp</code> 内使用，不会同其他 <code>cpp</code> 中的同名函数引起冲突。函数的定义和声明在默认情况下都是 <code>extern</code> 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用</p>
</li>
<li>
<p>在 <code>C++</code> 中，当 <code>static</code> 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
</li>
<li>
<p>静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。</p>
</li>
</ul>
<h3 id="extern"><code>extern</code></h3>
<ul>
<li>
<p><code>extern</code> 用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当使用 <code>extern</code> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
</li>
<li>
<p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <code>extern</code> 来得到已定义的变量或函数的引用。可以这么理解，<code>extern</code> 是用来在另一个文件中声明一个全局变量或函数。</p>
</li>
<li>
<p><code>extern</code> 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。</p>
</li>
</ul>
<h3 id="stdout-stderr"><code>stdout</code> &amp; <code>stderr</code></h3>
<ul>
<li>
<p><code>stdout &amp; stderr</code> 默认均为向屏幕输出。</p>
</li>
<li>
<p>当输出重定向至磁盘文件时，<code>stdout</code> 可以重定向到磁盘文件存储而 <code>stderr</code> 不行。</p>
</li>
<li>
<p>对于 <code>Linux</code> 环境下（<strong>未测验，据网上讲解</strong>）:</p>
<ol>
<li>
<p><code>stdout</code>（标准输出），输出方式是行缓冲。输出的字符会先存放在缓冲区，等按下回车键时才进行实际的 <code>I/O</code> 操作。</p>
</li>
<li>
<p><code>stderr</code>（标准错误），是不带缓冲的，这使得出错信息可以直接尽快地显示出来。</p>
</li>
</ol>
</li>
<li>
<p>对于 <code>Windows</code> 环境下（<strong>已编写程序测验</strong>）：</p>
<p><code>stdout</code> 和 <code>stderr</code> 均直接输出，即 <code>stdout</code> 不碰到回车符也会输出。</p>
</li>
</ul>
<h3 id="size_t"><code>size_t</code></h3>
<ul>
<li><code>size_t</code> 通常被用于数组索引和循环计数。使用其它类型来进行数组索引操作的程序可能会在某些情况下出错。</li>
</ul>
<h2 id="cc-中的内置函数"><code>C/C++</code> 中的内置函数</h2>
<h3 id="sizeof"><code>sizeof()</code></h3>
<ul>
<li>
<p>对于一个空类型/只有构造函数和析构函数的类型，占用多少内存（对类求 <code>sizeof()</code> 的结果）由编译器决定（<code>VS</code> 中为 <code>1</code>）。</p>
</li>
<li>
<p>对于一个数组，<code>sizeof</code> 求整个数组的大小。</p>
</li>
</ul>
<h3 id="assert-int-expression"><code>assert( int expression )</code></h3>
<ul>
<li>
<p><code>assert</code> 的作用是先计算表达式 <code>expression</code>，如果其值为假（即为<code>0</code>）那么它先向 <code>stderr</code> 打印一条出错信息,然后通过调用 abort 来终止程序运行。</p>
</li>
<li>
<p>使用 <code>assert</code> 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。</p>
</li>
</ul>
<h2 id="stl-相关"><code>STL</code> 相关</h2>
<h3 id="vector"><code>vector</code></h3>
<ul>
<li>
<p>底层基于数组实现。</p>
</li>
<li>
<p>拥有一段连续的内存空间，支持随机访问且随机访问性能好，插入删除性能差，一次性分配好内存，不够时才进行扩容。</p>
</li>
<li>
<p><code>vector</code>每次扩充容量时，新的容量都是前一次的两倍（这样可以保证常数时间的时间复杂度）。把之前的数据复制到新的数组中，再释放之前的内存（在时间性能有负面影响）。</p>
</li>
</ul>
<h3 id="list"><code>list</code></h3>
<ul>
<li>
<p>底层基于双向链表实现。</p>
</li>
<li>
<p>占用内存不连续，不支持随机访问，插入删除性能好，每次插入新节点都会进行内存申请。</p>
</li>
</ul>
<h3 id="set"><code>set</code></h3>
<ul>
<li>底层基于红黑树实现，适用于有序不重复集合。</li>
</ul>
<h3 id="map"><code>map</code></h3>
<ul>
<li>底层基于红黑树实现，适用于不重复映射的有序键值对。</li>
</ul>
<h3 id="unordered_map"><code>unordered_map</code></h3>
<ul>
<li>底层基于哈希表实现，无序。</li>
</ul>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://geniusmiaozz.github.io/tag/SJvu8fO9z/">
            <span class="flex-auto">GeniusMiaoStudy</span>
          </a>
        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://geniusmiaozz.github.io/post/xiao-xiao-suan-fa-________problem1~30/">
                <h3 class="post-title">
                  小小算法，________(Problem1~30)
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'd666ec54fdd7e7bcf5a5',
    clientSecret: 'eb4829aff529a141e142de8a677d7b34925325a6',
    repo: 'geniusmiaozz.github.io',
    owner: 'GeniusMiaozz',
    admin: ['GeniusMiaozz'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://geniusmiaozz.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
