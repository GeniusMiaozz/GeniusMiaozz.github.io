<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GeniusMiao&#39;s blog.</title>
<meta name="description" content="醉梦不知天在水，满船新梦压清河。" />
<link rel="shortcut icon" href="https://geniusmiaozz.github.io/favicon.ico?v=1586238965974">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://geniusmiaozz.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://geniusmiaozz.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://geniusmiaozz.github.io/images/avatar.png?v=1586238965974" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">GeniusMiao&#39;s blog.</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3">基础数据/结构/类型/内存相关</a>
<ul>
<li><a href="#%E5%B8%B8%E9%87%8F2020322">常量（2020.3.22）</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B02020322">浮点数（2020.3.22）</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B22020311">字符串（2020.3.11）</a></li>
<li><a href="#%E6%8C%87%E9%92%88202036">指针（2020.3.6）</a></li>
<li><a href="#c%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">C中的动态内存分配</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E7%B1%BB2020322">存储类（2020.3.22）</a></li>
<li><a href="#%E4%BD%8D%E5%9F%9F2020322">位域（2020.3.22）</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3">函数相关</a>
<ul>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B02020322">可变参数的函数（2020.3.22）</a></li>
<li><a href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B02020322">回调函数（2020.3.22）</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3">面向对象相关</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80202036">对象内存布局（2020.3.6）</a></li>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0202036">虚函数（2020.3.6）</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E8%A1%A5%E9%BD%902020322">内存补齐（2020.3.22）</a></li>
<li><a href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%8D%E7%BD%AEconst%E4%B8%8E%E5%90%8E%E7%BD%AEconst">类成员函数的前置const与后置const</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a>
<ul>
<li><a href="#%E9%A2%84%E5%A4%84%E7%90%862020322">预处理（2020.3.22）</a></li>
</ul>
</li>
<li><a href="#cc%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97">C/C++中的关键字</a>
<ul>
<li><a href="#null%E5%92%8Cnullptr202036">NULL和nullptr（2020.3.6）</a></li>
<li><a href="#delete%E5%92%8Cdelete202036">delete[]和delete（2020.3.6）</a></li>
<li><a href="#auto2020322">auto（2020.3.22）</a></li>
<li><a href="#regiter2020322">regiter（2020.3.22）</a></li>
<li><a href="#static2020322">static（2020.3.22）</a></li>
<li><a href="#extern2020322">extern（2020.3.22）</a></li>
<li><a href="#stdout-stderr">stdout &amp; stderr</a></li>
<li><a href="#size_t2020323">size_t（2020.3.23）</a></li>
</ul>
</li>
<li><a href="#cc%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">C/C++中的内置函数</a>
<ul>
<li><a href="#sizeof202036">sizeof()（2020.3.6）</a></li>
<li><a href="#assert-int-expression-202045">assert( int expression )（2020.4.5）</a></li>
</ul>
</li>
<li><a href="#stl%E7%9B%B8%E5%85%B3">STL相关</a>
<ul>
<li><a href="#vector202037">vector（2020.3.7）</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Homepage
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          Historical articles
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          About me
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://geniusmiaozz.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">C/C++复习</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-07 / 12 min read
        </div>
        
        <div class="post-content yue">
          <h2 id="基础数据结构类型内存相关">基础数据/结构/类型/内存相关</h2>
<h3 id="常量2020322">常量（2020.3.22）</h3>
<ul>
<li>
<p>整数常量：前缀 0X 或 0x 代表十六进制，前缀 0 表示八进制，不带前缀默认为十进制；后缀 U/u 代表无符号整数，L/l 代表长整数。</p>
</li>
<li>
<p>字符常量：\a 为警报铃声，\b 为退格键，\f 为换页符，\v 为垂直制表符，\ooo 为一到三位的八进制数，\xhhh ......为一道多个数字的十六进制数。</p>
</li>
<li>
<p>对于常量的定义，多推荐为大写字母的形式。</p>
</li>
</ul>
<h3 id="浮点数2020322">浮点数（2020.3.22）</h3>
<ul>
<li>浮点数的比较不能直接使用 '=' 进行判断，可以使用减法，当差值在精度允许范围内（比如0.0000001）即可视为两个浮点数相等。</li>
</ul>
<h3 id="字符串2020311">字符串（2020.3.11）</h3>
<ul>
<li>对于char str1[] 和 str2[]，如果二者赋值相同，由于 str1 和 str2 初始地址不同，str1 != str2；对于char *str1 和 *str2，如果二者赋值相同，相当于二者指向内存中同一段地址，str1 = str2。</li>
</ul>
<h3 id="指针202036">指针（2020.3.6）</h3>
<ul>
<li>
<p>32 位机器一个指针占 4 字节空间，64 位机器一个指针占8字节空间。</p>
</li>
<li>
<p>数组做为函数的参数传递时，自动退化为同类型指针，指向数组的第一个元素。<em>（2020.3.7）</em></p>
</li>
<li>
<p>指针函数：返回值是某一类型指针的函数，如 int *fun()，该函数返回值为一个地址；函数指针：指向某一函数的指针变量可以调用函数，如 int (*fun)() = &amp; fun1。<em>（2020.3.23）</em></p>
</li>
<li>
<p>指针数组：一个元素均为某一类型指针的的数组，如 int *p[10]，该数组包含是个int类型指针的元素；数组指针：指向数组某个元素地址的指针，如 int (*p) [10]，p指向数组的首地址（首个元素的地址）。<em>（2020.3.23）</em></p>
</li>
</ul>
<h3 id="c中的动态内存分配">C中的动态内存分配</h3>
<ul>
<li>
<p>可以利用四种方法进行动态内存操作：</p>
<blockquote>
<p>1.void *calloc(int num, int size)：在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0 。</p>
<p>2.void free(void *address)：该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</p>
<p>3.void *malloc(int num):在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</p>
<p>4.void *realloc(void \address, int newsize)：该函数重新分配内存，把内存扩展到 newsize。</p>
<p>4.void *memset(void *s, int ch, size_t n)：将 s 中当前位置后面的 n 个字节用 ch 替换并返回s。</p>
</blockquote>
</li>
</ul>
<h3 id="存储类2020322">存储类（2020.3.22）</h3>
<ul>
<li>
<p>存储类定义 C/C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。</p>
</li>
<li>
<p>存储类主要包含四种：auto、register、static、extern。（在关键字部分记录）</p>
</li>
</ul>
<h3 id="位域2020322">位域（2020.3.22）</h3>
<ul>
<li>位域在本质上就是一种结构体类型，只不过其成员按二进制中的每一位分配。</li>
</ul>
<h2 id="函数相关">函数相关</h2>
<h3 id="可变参数的函数2020322">可变参数的函数（2020.3.22）</h3>
<ul>
<li>
<p>该功能在 stdarg.h 头文件中实现。使用该功能的具体步骤可以概括为：</p>
<blockquote>
<p>1.定义一个函数，最后一个参数为省略号，省略号之前的参数是 int，代表了要传递的可变参数的总数。</p>
<p>2.在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</p>
<p>3.使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</p>
<p>4.使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</p>
<p>5.使用宏 va_end 来清理赋予 va_list 变量的内存。</p>
</blockquote>
</li>
</ul>
<h3 id="回调函数2020322">回调函数（2020.3.22）</h3>
<ul>
<li>
<p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单来说：回调函数是由别人的函数执行时调用你实现的函数。</p>
</li>
<li>
<p>一个回调函数的通俗解释，源于<a href="https://www.zhihu.com/answer/13005983">知乎回答</a>：你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</li>
</ul>
<h2 id="面向对象相关">面向对象相关</h2>
<h3 id="对象内存布局202036">对象内存布局（2020.3.6）</h3>
<ul>
<li>
<p>最基本的对象内存计算规则：对象的内存大小为成员变量的内存之和，成员函数不占内存，无成员变量的对象大小为 1 字节。</p>
</li>
<li>
<p>对于一个只包含非静态成员变量和普通成员函数的类，成员函数放在代码区，该类所有对象公有这一个；成员变量放在堆区，该类对象私有，每新建一个对象都回新建一块内存区域。</p>
</li>
<li>
<p>当有类中有虚函数时，会为该类的每一个实例在堆区添加一个指向虚函数表的指针。</p>
</li>
<li>
<p>类中的 static 成员变量不占用内存该类自身实例化对象的内存。<em>（2020.3.22）</em></p>
</li>
</ul>
<h3 id="虚函数202036">虚函数（2020.3.6）</h3>
<ul>
<li>
<p>虚函数讲解：<a href="https://zhuanlan.zhihu.com/p/28530472">知乎文章</a></p>
</li>
<li>
<p>通过对象内存中的 vptr 找到虚函数表 vtbl，表中存放着虚函数的指针，通过该指针找到对应虚函数的实现区域并进行调用。</p>
</li>
<li>
<p>构造函数不可以是虚函数，析构函数可以是虚函数且推荐设置为虚函数。</p>
</li>
</ul>
<h3 id="内存补齐2020322">内存补齐（2020.3.22）</h3>
<ul>
<li>
<p>内存补齐讲解：<a href="https://zhuanlan.zhihu.com/p/32261819">知乎文章</a></p>
</li>
<li>
<p>内存补齐主要遵循两条基本规则：</p>
<p>1、成员变量的偏移量必须为该变量自身大小的整数倍；</p>
<p>2、对象内存的大小为最大成员变量大小的整数倍；</p>
</li>
<li>
<p>宏 #pragma pack (n) 可以强制设定偏移量为 n 或自身内存大小中较小值的整数倍，n 为 1 时即设置为无内存补齐。</p>
</li>
</ul>
<h3 id="类成员函数的前置const与后置const">类成员函数的前置const与后置const</h3>
<ul>
<li>
<p>当 const 在函数名前面的时候修饰的是函数返回值，函数返回一个常量值。</p>
</li>
<li>
<p>当 const 在函数名后面的输给表示是该类的常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作；对于该类的 const 的对象，不能引用非 const 的成员函数（只能引用后置 const 修饰的常成员函数）。</p>
</li>
</ul>
<h2 id="其它">其它</h2>
<h3 id="预处理2020322">预处理（2020.3.22）</h3>
<ul>
<li>
<p>ANSI C预定义了一些宏可以直接使用但不可以修改，包括：</p>
<blockquote>
<p>1.__DATE__：当前日期，一个以 &quot;MMM DD YYYY&quot; 格式表示的字符常量。</p>
<p>2.__TIME__：当前时间，一个以 &quot;HH:MM:SS&quot; 格式表示的字符常量。</p>
<p>3.__FILE__：这会包含当前文件名，一个字符串常量。</p>
<p>4.__LINE__：这会包含当前行号，一个十进制常量。</p>
<p>5.__STDC__：当编译器以 ANSI 标准编译时，则定义为 1。</p>
</blockquote>
</li>
<li>
<p>预处理器运算符</p>
<blockquote>
<p>1.宏延续运算符（\）：一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。</p>
<p>2.字符串常量化运算符（#）：在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。</p>
<p>3.标记粘贴运算符（##）：宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。</p>
<p>4.defined() 运算符：预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。</p>
</blockquote>
</li>
</ul>
<h2 id="cc中的关键字">C/C++中的关键字</h2>
<h3 id="null和nullptr202036">NULL和nullptr（2020.3.6）</h3>
<ul>
<li>在编译时 NULL 会被解释为 0 ，而 nullptr 就代表空指针。</li>
</ul>
<h3 id="delete和delete202036">delete[]和delete（2020.3.6）</h3>
<ul>
<li>
<p>区别讲解：<a href="https://blog.csdn.net/u012936940/article/details/80919880">CSDN文章</a></p>
</li>
<li>
<p>概括的为：对于基本数据类型（如 int）二者无差别，对于自定义类型（通常指类）如果是 new 申请的内存，释放时用 delete；如果是使用 new []申请的内存，释放时要用 delete []。</p>
</li>
</ul>
<h3 id="auto2020322">auto（2020.3.22）</h3>
<ul>
<li>auto 是所有局部变量默认的存储类。auto 只能用在函数内，即 auto 只能修饰局部变量。</li>
</ul>
<h3 id="regiter2020322">regiter（2020.3.22）</h3>
<ul>
<li>
<p>register 用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。</p>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
</li>
</ul>
<h3 id="static2020322">static（2020.3.22）</h3>
<ul>
<li>
<p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
</li>
</ul>
<h3 id="extern2020322">extern（2020.3.22）</h3>
<ul>
<li>
<p>extern 用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。</p>
</li>
</ul>
<h3 id="stdout-stderr">stdout &amp; stderr</h3>
<ul>
<li>
<p>stdout &amp; stderr 默认均为向屏幕输出。</p>
</li>
<li>
<p>当输出重定向至磁盘文件时，stdout 可以重定向到磁盘文件存储二 stderr 不行。</p>
</li>
<li>
<p>对于Linux环境下（<strong>未测验，据网上讲解</strong>）:</p>
<blockquote>
<p>stdout（标准输出），输出方式是行缓冲。输出的字符会先存放在缓冲区，等按下回车键时才进行实际的 I/O 操作。</p>
<p>stderr（标准错误），是不带缓冲的，这使得出错信息可以直接尽快地显示出来。</p>
</blockquote>
</li>
<li>
<p>对于Windows环境下（<strong>已编写程序测验</strong>）：</p>
<blockquote>
<p>stdout 和 stderr 均直接输出，即 stdout 不碰到回车符也会输出。</p>
</blockquote>
</li>
</ul>
<h3 id="size_t2020323">size_t（2020.3.23）</h3>
<ul>
<li>size_t 通常被用于数组索引和循环计数。使用其它类型来进行数组索引操作的程序可能会在某些情况下出错。</li>
</ul>
<h2 id="cc中的内置函数">C/C++中的内置函数</h2>
<h3 id="sizeof202036">sizeof()（2020.3.6）</h3>
<ul>
<li>
<p>对于一个空类型/只有构造函数和析构函数的类型，占用多少内存由编译器决定（VS 中为 1）。</p>
</li>
<li>
<p>对于一个数组，sizeof求整个数组的大小。<em>（2020.3.7）</em></p>
</li>
</ul>
<h3 id="assert-int-expression-202045">assert( int expression )（2020.4.5）</h3>
<ul>
<li>
<p>assert 的作用是先计算表达式 expression，如果其值为假（即为0）那么它先向 <code>stderr</code> 打印一条出错信息,然后通过调用 abort 来终止程序运行。</p>
</li>
<li>
<p>使用 <code>assert</code> 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。</p>
</li>
</ul>
<h2 id="stl相关">STL相关</h2>
<h3 id="vector202037">vector（2020.3.7）</h3>
<ul>
<li>vector每次扩充容量时，新的容量都是前一次的两倍。把之前的数据复制到新的数组中，再释放之前的内存。（时间性能有负面影响）。</li>
</ul>

        </div>

        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://geniusmiaozz.github.io/post/yi-ge-jian-dan-de-xiao-xing-xiao-yuan-wang-ru-he-she-ji/">
                <h3 class="post-title">
                  一个简单的小型校园网如何设计？
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'd666ec54fdd7e7bcf5a5',
    clientSecret: 'eb4829aff529a141e142de8a677d7b34925325a6',
    repo: 'geniusmiaozz.github.io',
    owner: 'GeniusMiaozz',
    admin: ['GeniusMiaozz'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://geniusmiaozz.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
