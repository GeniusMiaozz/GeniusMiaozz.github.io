<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GeniusMiao&#39;s blog.</title>
<meta name="description" content="醉梦不知天在水，满船新梦压清河。" />
<link rel="shortcut icon" href="https://geniusmiaozz.github.io/favicon.ico?v=1586269743639">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://geniusmiaozz.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://geniusmiaozz.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://geniusmiaozz.github.io/images/avatar.png?v=1586269743639" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">GeniusMiao&#39;s blog.</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%A6%82%E5%86%B5%E6%80%BB%E7%BB%93">概况总结</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E6%80%BB%E8%A7%88">题目总览</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E5%B0%8F%E8%AE%B0">题目小记</a>
<ul>
<li><a href="#1%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0">1.赋值运算符函数</a></li>
<li><a href="#2%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">2.数组中重复的数字</a></li>
<li><a href="#3%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">3.二维数组中的查找</a></li>
<li><a href="#4%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">4.替换空格</a></li>
<li><a href="#5%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">5.从尾到头打印链表</a></li>
<li><a href="#6%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">6.重建二叉树</a></li>
<li><a href="#7%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9">7.二叉树的下一个节点</a></li>
<li><a href="#8%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">8.用两个栈实现队列</a></li>
<li><a href="#9%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">9.斐波那契数列</a></li>
<li><a href="#10%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">10.旋转数组的最小数字</a></li>
<li><a href="#11%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">11.矩阵中的路径</a></li>
<li><a href="#12%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4">12.机器人的运动范围</a></li>
<li><a href="#13%E5%89%AA%E7%BB%B3%E5%AD%90">13.剪绳子</a></li>
<li><a href="#14%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0">14.二进制中 1 的个数</a></li>
<li><a href="#15%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">15.数值的整数次方</a></li>
<li><a href="#16%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0">16.打印从1到最大的n位数</a></li>
<li><a href="#17%E5%9C%A8o1%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9">17.在O(1)时间删除链表节点</a></li>
<li><a href="#18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9">18.删除链表中重复的节点</a></li>
<li><a href="#19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D">19.正则表达式的匹配</a></li>
<li><a href="#20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">20.表示数值的字符串</a></li>
<li><a href="#21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">21.调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="#22%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">22.链表的倒数第k个节点</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Homepage
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          Historical articles
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          About me
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://geniusmiaozz.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">编程题，拿下!(第一阶段Day1~Day30)</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-07 / 30 min read
        </div>
        
        <div class="post-content yue">
          <h2 id="概况总结">概况总结</h2>
<p>第一阶段主要以复习巩固基础知识为主，同时对如何保证代码的可靠质量进行了学习。做题的主要方式为读题审题、理解解析、阅读源码、复现方法。</p>
<h2 id="题目总览">题目总览</h2>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">主要思想</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">赋值运算符函数</td>
<td style="text-align:center">熟悉语言特性，保证编程严谨性</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">数组中重复的数字</td>
<td style="text-align:center">利用一维数组的性质</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">二维数组中的查找</td>
<td style="text-align:center">利用二维数组的性质</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">替换空格</td>
<td style="text-align:center">利用字符串的性质</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">从尾到头打印链表</td>
<td style="text-align:center">利用链表与栈的性质</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">重建二叉树</td>
<td style="text-align:center">利用二叉树前序、中序遍历的性质</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">二叉树的下一个节点</td>
<td style="text-align:center">利用二叉树的性质</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">用两个栈实现队列</td>
<td style="text-align:center">利用栈与队列的性质</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">斐波那契数列</td>
<td style="text-align:center">考虑用递归及循环解决问题</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">旋转数组的最小数字</td>
<td style="text-align:center">利用二分查找法解决问题</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">矩阵中的路径</td>
<td style="text-align:center">利用回溯法</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">机器人的运动范围</td>
<td style="text-align:center">利用回溯法</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">剪绳子</td>
<td style="text-align:center">利用动态规划&amp;贪心算法</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">二进制中 <code>1</code> 的个数</td>
<td style="text-align:center">利用位运算</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">数值的整数次方</td>
<td style="text-align:center">考虑底数指数的符号情况</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">打印从 <code>1</code> 到最大的 <code>n</code> 位数</td>
<td style="text-align:center">考虑 <code>n</code> 较大的情况</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">在 <code>O(1)</code> 时间删除链表节点</td>
<td style="text-align:center">考虑链表长度及待删除节点位置的不同情况</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">删除链表中重复的节点</td>
<td style="text-align:center">考虑重复节点的位置的不同情况</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">正则表达式的匹配</td>
<td style="text-align:center">考虑多种匹配方式的不同情况</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">表示数值的字符串</td>
<td style="text-align:center">考虑一个正确的数值正则表达式设计</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">调整数组顺序使奇数位于偶数前面</td>
<td style="text-align:center">利用快速排序的思想，考虑可扩展的解法</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">链表的倒数第 <code>k</code> 个节点</td>
<td style="text-align:center">寻找规律，考虑链表头节点及链表节点数目的特殊情况</td>
</tr>
</tbody>
</table>
<h2 id="题目小记">题目小记</h2>
<h3 id="1赋值运算符函数">1.赋值运算符函数</h3>
<ul>
<li>
<p>题目内容</p>
<p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p>
<pre><code class="language-C++">class CMyString
{
public:
    CMyString(char *pData = nullptr);
    CMyString(const CMyString &amp;str);
    ~CMyString(void);

    CMyString &amp;operator=(const CMyString &amp;str);
    void Print();

private:
    char *m_pData;
};
</code></pre>
</li>
<li>
<p>解题思路</p>
<p>对于为一个自定类构造赋值运算符函数，解法并不是重点，重点是解决方法中应注意的事项。主要应关注以下几点：</p>
<ol>
<li>
<p>把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。这样能保证能够连续多次赋值。</p>
</li>
<li>
<p>把传入的参数的类型声明为常量引用。这样能够在传入实例时避免调用一次复制构造函数，减少消耗。</p>
</li>
<li>
<p>赋值前释放实例自身已有内存。这样能够避免内存泄漏。</p>
</li>
<li>
<p>如果传入参数和当前实例是同一个实例，直接返回无需进行复制操作。这样能够避免在释放实例自身内存时也释放掉了传入参数的内存。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>对于上述思路，存在如下一种情况：当在delete释放原有实例内存之后，如果此时内存不足将导致后面的new char抛出异常，而在上述思路中这样的异常会导致很严重的问题。</p>
<p>故可以改进一下思路：进行一个if判断，如果传入参数和当前实例不是同一个对象，则新实例化一个对象和当前进行交换，并返回当前实例。<br>
<strong>在这种方法下，如果一切正常运行，新实例化的对象在if作用域结束时会自动调用析构函数，而由于已经发生了指向内存的交换，实际释放的是旧实例的内存，并返回新实例的指针；如果运行出现异常，由于还没有修改原来实例的状态，能够保证异常安全性。</strong></p>
</li>
</ul>
<h3 id="2数组中重复的数字">2.数组中重复的数字</h3>
<ul>
<li>
<p>题目内容</p>
<p>在一个长度为n的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>直接利用一个哈希表来解决这个问题，这种解法的时间复杂度以及空间复杂度均为 <code>O(N)</code>。</p>
</li>
<li>
<p>考虑这个数组的性质：如果这个数组是无重复数字且升序排序的，那么数字 <code>i</code> 应该出现在下标为 <code>i</code> 的位置。如果这个数组有重复数字，那么升序排序之后有些位置的下标 <code>i</code> 和该位置的值则不相等。</p>
</li>
<li>
<p>改进后的解法：遍历这个数组，当扫描到下标为 <code>i</code> 的数字(假设为 <code>number[i]</code>)时，首先比较 <code>number[i]</code> 是否等于 <code>i</code>，如果是，接着扫描下一个数字；如果不是，拿它和下标为 <code>number[i]</code> 的数字(即 <code>number[number[i]]</code>)比较，如果相同则找到了一个重复的数字，如果不相同就把这两个数字进行交换(<code>Swap(number[i],number[number[i]])</code>)。重复这个比较、交换的过程。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>上述解法需要对数组进行修改，如果不能对数组进行修改，可以考虑利用二分查找的思想解题。把 <code>1~n</code> 的数字从中间数字 <code>m</code> 分为两部分，前面一半为 <code>1~n</code> ，后面一半为 <code>m+1~n</code> 。如果前一半的数字数目超过了m，那么代表数组中一定有至少一个重复数字范围在 <code>1~n</code> 内，反之则在 <code>m+1~n</code> 内。不断的缩写查找范围重复这个过程，直到查找范围仅包含一个数字为止。</p>
</li>
</ul>
<h3 id="3二维数组中的查找">3.二维数组中的查找</h3>
<ul>
<li>
<p>题目内容</p>
<p>在一个二维层次中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</li>
<li>
<p>解题思路</p>
<p>先查看数组右上角的数字，如果等于目标数字则返回。如果大于目标数字，则令查找范围的最大列号减一；如果这个数字小于目标数字，则令查找范围的最小行号减一。不断缩小查找范围，直到找到目标数字或查找范围为空。</p>
</li>
</ul>
<h3 id="4替换空格">4.替换空格</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数，把串联中的每个间隔替换成“％20”。例如输入“ We are happy。”，则输出“ We％20are％20happy。”。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>每有一个 <code>' '</code> 变为 <code>'%20'</code> 就会使字符串的长度增加2，根据这个性质，首先遍历一次字符串，得到正确转换后的新字符串长度。</p>
</li>
<li>
<p>定义两个指针，第一个指针指向源字符串的末尾(角标为旧字符串的长度减一)，第二个指针指向转换后字符串的末尾(角标为转换后的字符串长度减一)。不断得同步向前移动两个指针遍历数组：如果第一个指针位置的字符不是 <code>' '</code>，则把该字符复制到第二个指针位置的字符内容；如果第一个指针位置的字符是 <code>' '</code>，令指针一的位置向前移动一次，再依次在指针二的位置填入 <code>'0'</code>、<code>'2'</code>、<code>'%'</code>，每次填入后令指针二的位置向前移动一次。直到指针一位置的下标小于零。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>在合并两个数组或是字符串时，考虑使用从后往前复制的方法可以减少复制次数、优化效率。</p>
</li>
</ul>
<h3 id="5从尾到头打印链表">5.从尾到头打印链表</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>利用栈的思路解题</p>
<p>先遍历一次链表，每扫描到一个节点时将该节点压入栈中。遍历结束之后，不断地打印栈顶节点并弹栈，直到栈中为空为止。</p>
</li>
<li>
<p>利用递归的思路解题</p>
<p>遍历一次链表，每扫描到一个节点时如果该节点的下一个节点非空，递归调用本函数并将函数参数设为当前节点的下一个节点，然后输出当前节点的信息。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>当链表非常长时不适宜使用递归的方法，因为有可能导致函数调用栈溢出。</p>
</li>
</ul>
<h3 id="6重建二叉树">6.重建二叉树</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出原始二叉树并输出它的头节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>假设前序遍历数组的起始及终止位置为 <code>startPreorder</code> 和 <code>endPreorder</code>,<br>
中序遍历数组的起始及终止位置为 <code>startInorder</code> 和 <code>endInorder</code>。</p>
</li>
<li>
<p>首先根据前序遍历第一个节点的值建立根节点，然后在中序遍历中查找根节点的位置，如果没有找到则抛出异常。假设中序遍历数组中根节点的位置为 <code>rootInorder</code>。</p>
</li>
<li>
<p>在中序遍历中，利用 <code>rootInorder - startInorder</code> 求得根节点左子树中序遍历的长度，假设该值为 <code>m</code>。在前序遍历中，除去首元素(根节点)外的前 <code>m</code> 个元素为根节点左子树的前序遍历。</p>
</li>
<li>
<p>类似的，前序遍历中除去前 <code>(m+1)</code> 个元素(除去根节点和根节点左子树的前序遍历)为根节点右子树的前序遍历，中序遍历中根节点右侧的序列为根节点右子树的中序遍历。</p>
</li>
<li>
<p>如果 <code>m</code> 的值大于零，代表当前根节点左子树非空，递归重建左子树；如果 <code>endPreorder - startPreorder</code> 的值大于 <code>m</code> ，则代表根节点的右子树非空，递归重建右子树</p>
</li>
<li>
<p>递归的终止条件：某一次递归调用时传入参数中前序遍历数组的长度、中序遍历数组的长度均为 <code>1</code>，且两个数组的唯一元素值相等，递归结束，返回。</p>
</li>
</ol>
</li>
</ul>
<h3 id="7二叉树的下一个节点">7.二叉树的下一个节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>给定一棵二叉树和其中的一个节点，如何找出中序遍历顺序的下一个节点？前提：树中的节点除了有两个分别指向左右子节点的指针以外，还有一个指向父节点的指针。</p>
</li>
<li>
<p>解题思路</p>
<p>对于一个二叉树中，求一个节点在中序遍历中的下一个节点：</p>
<ol>
<li>
<p>如果这个节点有右子树，那么下一个节点为该节点右子树的最左子节点。</p>
</li>
<li>
<p>如果该节点没有右子树，但是该节点是父节点的左子节点，那么下一个节点为该节点的父节点。</p>
</li>
<li>
<p>如果该节点没有右子树还是父节点的右子节点，那么就要沿着父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，这个节点的父节点就是下一个节点。</p>
</li>
</ol>
</li>
</ul>
<h3 id="8用两个栈实现队列">8.用两个栈实现队列</h3>
<ul>
<li>
<p>题目内容</p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>设两个栈分别为 <code>stack1</code>、<code>stack2</code>。</p>
</li>
<li>
<p>进队列：元素进 <code>stack1</code> 栈。</p>
</li>
<li>
<p>出队列：<code>stack1</code> 中的元素依次出栈，并入 <code>stack2</code> 栈。<code>stack2</code> 栈顶元素出栈为出队列元素。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>用两个队列实现一个栈的方法：</p>
<ol>
<li>
<p>入栈：哪个队列非空入哪个队列。</p>
</li>
<li>
<p>出栈：非空队列中的元素依次出队列并进入另一个队列，最后一个出队列的元素为实际上出栈的元素。</p>
</li>
</ol>
</li>
</ul>
<h3 id="9斐波那契数列">9.斐波那契数列</h3>
<ul>
<li>
<p>题目内容</p>
<p>写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题利用基本的递归方法效率很低，会对若干个值进行反复求解。</p>
</li>
<li>
<p>为了避免重复计算，做一个 <code>n - 2</code> 次的迭代，每次求得当前元素的前两项和，然后更新前两项元素的值即可。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>一些题目经过思考会发现本质上也是斐波那契数列问题。</p>
<ol>
<li>
<p>青蛙跳台阶问题：一只青蛙一次可以调上一级台阶也可以跳上两级台阶，求该青蛙跳上一个 <code>n</code> 级台阶总共有多少种跳法。</p>
</li>
<li>
<p>矩形覆盖问题：用一个 <code>2*1</code> 的小矩形横着或竖着去覆盖一个 <code>2*8</code> 的大矩形，总共有多少种方法？</p>
</li>
</ol>
</li>
</ul>
<h3 id="10旋转数组的最小数字">10.旋转数组的最小数字</h3>
<ul>
<li>
<p>题目内容</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>利用二分查找的思想解题。分别取首元素位置 <code>index1</code> 和 尾元素位置 <code>index1</code>，同时因为存在将 <code>0</code> 个数字搬到最后面的情况，先去中间元素的位置 <code>indexMid</code> 为0，保证得到正确的结果。</p>
</li>
<li>
<p>以 <code>index1</code> 位置的元素是否大于等于 <code>index2</code> 位置的元素作为条件循环，取 <code>index1</code> 与 <code>index2</code> 中间的元素，如果三个元素相等，则直接对数组遍历来找到最小元素；否则如果 <code>index1</code> 位置的元素小于等于 <code>indexMid</code>位置的元素，则最小数字在数组的后半段，令 <code>index1</code> 等于 <code>indexMid</code>；如果 <code>index2</code> 位置的元素大于等于 <code>indexMid</code> 位置的元素，则最小数字在数组的前半段，令 <code>index2</code> 等于 <code>indexMid</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="11矩阵中的路径">11.矩阵中的路径</h3>
<ul>
<li>
<p>题目内容</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br>
A B T G<br>
C F C S<br>
J D E H</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>利用回溯法解决的典型题。对矩阵中所有的格子挨个进行扫描，如果某个格子中的字符 <code>ch</code> 对应路径中的第 <code>i</code> 个字符，那么在这个相邻的格子寻找路径上的第 <code>i + 1</code> 个字符。不断重复这个过程，直到路径上的所有字符都在矩阵中找到对应的位置。</p>
</li>
<li>
<p>首先应有一个函数初始化一个存储格子是否被访问过信息的数组，并在这个函数中对格子中所有的节点进行扫描，判断从该格子触发是否能找到正确的路径(假设这个调用的判断函数为 <code>fun</code>)。</p>
</li>
<li>
<p>在 <code>fun</code> 函数中，如果当前路径读到的字符已遇到结束符，则代表在矩阵中找到了路径直接返回；否则如果当前传入格子(假设这个格子 为 <code>a</code>)的字符等于当前路径读到的字符，并且 <code>a</code> 这个格子没有被访问过，应该选取 <code>a</code> 这个格子作为下一步的行动路径，更改这个格子的访问信息为 <code>True</code>，然后递归调用 <code>fun</code> 函数检查 <code>a</code> 格子的相邻格子是否有路径中的下一个字符，如果有返回 <code>True</code>，如果没有应回溯一步，将 <code>a</code> 格子的访问信息更改为 <code>False</code>，返回 <code>True</code>进行下一个格子的判断。</p>
</li>
</ol>
</li>
</ul>
<h3 id="12机器人的运动范围">12.机器人的运动范围</h3>
<ul>
<li>
<p>题目内容</p>
<p>地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>从坐标 <code>(0,0)</code> 的位置开始移动，每当进入一个新位置时通过检查坐标的数位来判断机器人是否能够进入，如果能进入再递归判断四个相邻的格子是否能够进入。</p>
</li>
<li>
<p>首先应有一个函数初始化一个存储格子是否被访问过信息的数组，并在这个函数中对 <code>(0,0)</code> 这个位置进行扫描，判断从该初始位置触发最多能到达多少个格子(假设这个调用的统计函数为 <code>fun</code>)。</p>
</li>
<li>
<p>在 <code>fun</code> 函数中了，首先对当前传入的格子进行检查，如果不符合要求代表该格子无法到达，直接返回 <code>0</code>；如果符合要求，首先更改这个格子的访问信息为 <code>True</code>，对于从这个格子出发能够访问到的格子数量为 <code>1</code> 加上从相邻的四个格子能访问到的格子数。</p>
</li>
<li>
<p>考虑边界情况：对于一个边界的格子(该格子依然能到达)，如果它的四个相邻格子由于超出范围、已经访问过、不符合要求条件等原因已经不能再到达，那么该边界格子就会返回 <code>1 + 0 + 0 + 0 + 0</code>,而这个信息会逐层向上传递直到返回给初始格子。</p>
</li>
</ol>
</li>
</ul>
<h3 id="13剪绳子">13.剪绳子</h3>
<ul>
<li>
<p>题目内容</p>
<p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>动态规划的想法</p>
<ol>
<li>
<p>当绳子长度小于 <code>2</code> 时，无剪法，返回零；当绳子长度等于 <code>2</code> 时，返回最大值 <code>1</code>；当绳子长度等于 <code>3</code> 时，返回最大值 <code>2</code>。</p>
</li>
<li>
<p>初始化一个长度为绳子长度的数组 <code>products</code>，前四项分别为 <code>0、1、2、3</code>。从第五项开始逐个扫描直至最后一项，每一项 <code>i</code> 结果最大值 <code>products[i]</code> 为 <code>max(products[j] * products[i - j])</code>，其中 <code>j ∈ 1 ~ i / 2</code>。</p>
</li>
</ol>
</li>
<li>
<p>贪婪算法的想法</p>
<p>利用数学可以证明：当绳子的长度大于 <code>5</code> 时，尽可能多剪长度为 <code>3</code> 的绳子段会使结果值达到最大值；而当剩余绳子长度小于 <code>5</code> 时，剪为两根长度为 <code>2</code> 的绳子达到最大值。</p>
</li>
</ol>
</li>
</ul>
<h3 id="14二进制中-1-的个数">14.二进制中 1 的个数</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>常规思路</p>
<p>设定一个 <code>flag = 1</code>。不断求输入数字 <code>n</code> 与 <code>flag</code> 相与得到的结果，如果结果不为 <code>0</code> 则令计数值 <code>count</code> 加一，这样循环的次数是整数二进制的位数。</p>
</li>
<li>
<p>改进思路</p>
<ol>
<li>
<p>如果把一个二进制表示的整数减去一，都是把最右边的 <code>1</code> 变成 <code>0</code>，如果它的右边还有 <code>0</code>，就把这些 <code>0</code> 全变成 <code>1</code>。</p>
</li>
<li>
<p>故可以发现：把输入数字 <code>n</code> 与 <code>n - 1</code> 进行与运算并赋值给 <code>n</code>，相当于把 <code>n</code> 中的最低位的 <code>1</code> 变为 <code>0</code> 而其他位保持不变。基于这种思路的解法，循环次数为 <code>n</code> 的二进制表示中 <code>1</code> 的个数。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="15数值的整数次方">15.数值的整数次方</h3>
<ul>
<li>
<p>题目内容</p>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题的关键之一就是确保代码的完整性。如果传入的底数为 <code>0</code>，直接返回 <code>0</code> 即可。</p>
</li>
<li>
<p>对于指数为负数的情况，应当首先对指数取绝对值，然后对计算的结果取倒数；对于指数为正数的情况直接调用函数计算结果皆可。</p>
</li>
<li>
<p>如何完成一个函数计算底数的指数次幂：当指数为 <code>0</code> 时，返回 <code>1</code>；当指数为 <code>1</code> 时，返回底数；否则递归调用本函数计算当前传入参数中底数的(指数 / 2)次幂，对该结果做平方，如果指数为计数再令该结果乘上一次底数并复制给自身，然后返回该结果。</p>
</li>
</ol>
</li>
</ul>
<h3 id="16打印从1到最大的n位数">16.打印从1到最大的n位数</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>在字符串上模拟数字加法的思路</p>
<ol>
<li>
<p>首先初始化一个长度为 <code>n + 1</code> 的字符串，用来存放 <code>n</code> 位数字的每一位及字符串的终止符 <code>\0</code>。通过函数 <code>fun1</code> 来对字符串模拟整数加一的操作并判断当前是否已累加至最大数字，然后通过函数 <code>fun2</code> 来打印信息。</p>
</li>
<li>
<p>在 <code>fun1</code> 的执行过程中，从字符串(假设为 <code>number</code>)的最低位(假设为 <code>i = length - 1</code>)开始依次取单个数字，每次取数字后应直接加上前一位传来的进位标志位，即 <code>nSum = number[i] - '0' + nTakeOver</code>。当取到的数字为最低位时，应执行加一操作，首先令 <code>nSum</code> 加一。</p>
</li>
<li>
<p>然后判断 <code>nSum</code> 的值，如果 <code>nSum &gt;= 10</code> 且当前位为最高位(<code>i = 0</code>)，代表已累加至 <code>n</code> 位数最大值，返回 <code>True</code>；如果当前位不是最高位，由于产生了进位，应置这一位的值归零，同时置进位标志位为 <code>1</code> 以使高一位的值加一。</p>
</li>
<li>
<p>如果 <code>nSum &lt; 10</code> ，代表本次加一的操作正常执行且没有发生进位，此时直接返回 <code>False</code>。</p>
</li>
<li>
<p>在 <code>fun2</code> 的执行过程中，应该从左到右逐个字符扫描字符串，当碰到第一个非 <code>0</code> 的字符之后开始打印，直至字符串的结尾。</p>
</li>
</ol>
</li>
<li>
<p>基于递归的数字排列思路</p>
<ol>
<li>
<p>首先初始化一个长度为 <code>n + 1</code> 的字符串，用来存放 <code>n</code> 位数字的每一位及字符串的终止符 <code>\0</code>。首先对字符串的最高位(<code>i = 0</code>)进行 <code>0 ~ 9</code> 的枚举，对于对于每种情况调用函数 <code>fun</code> 来进行处理。</p>
</li>
<li>
<p>在 <code>fun</code> 函数中首先判断传入参数中当前选中位是否为最低位(<code>if(index == length - 1)</code>)，如果为最低位调用 <code>fun2</code> 函数输出数字；否则对当前选中位的低一位(<code>index + 1</code>)进行 <code>0 ~ 9</code> 的枚举，递归调用 <code>fun</code> 函数处理。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="17在o1时间删除链表节点">17.在O(1)时间删除链表节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>如果要删除的节点不是尾节点(代表链表中至少有两个节点)，首先获取待删除节点(<code>pNeedDel</code>)的下一个节点(<code>pNext = pNeedDel -&gt; next</code>)，将下一个节点值的信息赋值给待删除的节点(<code>pNeedDel -&gt; value = pNext -&gt; value</code>)，然后将待删除节点的下一节点指针指向下一节点的下节点(<code>pNeedDel -&gt; next = pNext -&gt; next</code>)。最后删除下一节点(<code>pNext</code>)的内存，令该指针指向空。</p>
</li>
<li>
<p>如果当前链表只有一个节点，直接删除待删除的节点，令待删除节点的指针及头节点的指针指向空。</p>
</li>
<li>
<p>如果链表中有多个节点且待删除节点为尾节点，此时就需要从头遍历链表，找到尾节点的地址后再进行删除。</p>
</li>
</ol>
</li>
</ul>
<h3 id="18删除链表中重复的节点">18.删除链表中重复的节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>在一个排序的链表中，设计一个函数，删除所有重复的节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>由于头节点也有可能被删除，因此传入的参数应设为 <code>ListNode **pHead</code> 而不是 <code>ListNode *pHead</code>。</p>
</li>
<li>
<p>从头到尾遍历整个链表。如果当前节点的值与下一个节点的值相同，那么他们就是重复的节点，此时应将所有连续的重复节点删除，并保证当前节点的前一个节点与后边值比当前节点的值大的第一个节点相连。重复这个过程直到遍历到链表的最后一个节点。</p>
</li>
</ol>
</li>
</ul>
<h3 id="19正则表达式的匹配">19.正则表达式的匹配</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数用来匹配包含'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;及&quot;ab*a&quot;均不匹配。</p>
</li>
<li>
<p>解题思路</p>
<p>在匹配的过程中，主要进行如下几种判断：</p>
<ol>
<li>
<p>如果当前字符串与模式读到的字符均为 <code>\0</code>，则整个字符串与表达式匹配成功返回 <code>True</code>。</p>
</li>
<li>
<p>如果当前字符串读到的字符不是 <code>\0</code> 而模式读到的字符为 <code>\0</code>，代表表达式未完全匹配整个字符串，字符串与表达式匹配失败返回 <code>False</code>。</p>
</li>
<li>
<p>如果模式中当前读入字符的下一个字符为 <code>*</code>，即能匹配任意个字符，则首先判断字符串及模式中的当前读入字符是否能匹配(即两个字符相等或字符串的当前读入字符不等于 <code>\0</code> 且模式的当前读入字符为 <code>'.'</code>)。</p>
<ul>
<li>
<p>如果能匹配，则针对下一个字符 <code>'*'</code> 有三种情况：</p>
<ol>
<li>
<p>在模式上向后移动两个字符，即忽略当前读入字符与下一个字符 <code>'*'</code> 的匹配。</p>
</li>
<li>
<p>在字符串上向后移动一个字符，模式上向后移动两个字符，即当前读入字符与下一个字符 <code>'*'</code> 匹配字符串中的一个字符。</p>
</li>
<li>
<p>字符串上向后移动一个字符，模式上向后移动零个字符，即当前读入字符与下一个字符 <code>'*'</code> 匹配字符串中的若干个字符。</p>
</li>
</ol>
</li>
<li>
<p>如果不能匹配，则针对下一个字符 <code>'*'</code> 只有一种情况：在模式上向后移动两个字符，即忽略当前读入字符与下一个字符 <code>'*'</code> 的匹配。</p>
</li>
</ul>
</li>
<li>
<p>如果模式中当前读入字符的下一个字符不是 <code>*</code>，则判断字符串及模式中的当前读入字符是否能匹配(即两个字符相等或字符串的当前读入字符不等于 <code>\0</code> 且模式的当前读入字符为 <code>'.'</code>)。如果匹配，则字符串上向后移动一个字符，模式上向后移动一个字符继续匹配。</p>
</li>
<li>
<p>所有其他情况均返回 <code>False</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="20表示数值的字符串">20.表示数值的字符串</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都表示数值，但“12e”、“1a3.14”、“1.2.3”、“+-5”及“12e+5.4”都不是。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>首先先扫描整数部分的正负号(<code>'+'</code> 或者 <code>'-'</code>)，正负号可能有也可能没有，如果有则匹配并定位字符串中的下一个字符。</p>
</li>
<li>
<p>然后尽可能多得匹配一个以 <code>0 ~ 9</code> 中数字构成的数字串，这一部分是数字的整数部分。如果整数部分匹配到了至少一个数字，此时返回一个初步结果 <code>True</code>，因为单纯的整数也是一个合理的数值。</p>
</li>
<li>
<p>接下来如果遇到小数点 <code>'.'</code>，尝试去匹配一个以 <code>0 ~ 9</code> 中数字构成的数字串，即小数点后面的小数部分。此时求得中间结果为初步结果与这一步结果的或运算值，因为一个小数可以没有整数部分(<code>.123</code>)、小数点后面也可以没有数字(<code>123.</code>)、或者小数点前面和后面均有数字(<code>123.123</code>)。</p>
</li>
<li>
<p>接下来如果遇到指数标志 <code>'e'</code> 或 <code>'E'</code>,尝试去匹配一个以 <code>'+'</code> 或者 <code>'-'</code> 开头(可以没有这个符号位)，其余以 <code>0 ~ 9</code> 中数字构成的数字串，即指数的数值。此时求得最终结果为中间结果与这一步结果的与运算值。因为指数标志 <code>'e'</code> 或 <code>'E'</code> 前面没有数字时整个字符串不能表示数字，而后面没有整数时也不能表示数字。</p>
</li>
<li>
<p>最终返回最终结果和当前字符串读入字符等于 <code>\0</code> 的与运算值，因为如果成功匹配了一个数值之后如果后面还有奇异字符依然为匹配失败。</p>
</li>
</ol>
</li>
</ul>
<h3 id="21调整数组顺序使奇数位于偶数前面">21.调整数组顺序使奇数位于偶数前面</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</li>
<li>
<p>解题思路</p>
<p>这道题可以直接利用快速排序的思想解题，分别用两个指针定位数组的首尾步，首指针向后移动，尾指针向前移动，每当首指针遇到一个偶数、尾指针遇到一个奇数停止移动，交换两个数，继续移动指针。重复这个过程，直到首指针的位置不小于尾指针的位置为止。</p>
</li>
<li>
<p>扩展思考</p>
<p>对于题中“判断遇到的数为奇数还是偶数”这一项，可以额外的增加一个函数专用来返回奇偶结果的判断值，这样在需要进行扩展修改时(如将所有偶数调整至奇数前面)可以很便捷地进行扩展。</p>
</li>
</ul>
<h3 id="22链表的倒数第k个节点">22.链表的倒数第k个节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如一个链表有6个节点，从头节点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>定义两个指针，第一个指针从链表的头指针开始遍历向前走 <code>k - 1</code> 步，第二个指针保持不动；从 <code>k</code> 步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针保持 <code>k - 1</code> 的距离，当第一个指针走到链表尾部的时候，第二个指针的位置为 <code>n - k + 1</code>，即倒数第 <code>k</code> 个节点。</p>
</li>
<li>
<p>本体需要考虑几种特殊情况：输入的头指针为空指针，应直接返回空指针；当链表节点数少于 <code>k</code> 时，应在前 <code>k - 1</code> 步时每一步判断下一节点是否为空指针；<code>k</code> 值为 <code>0</code>，应直接返回空指针。</p>
</li>
</ol>
</li>
</ul>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://geniusmiaozz.github.io/tag/SJvu8fO9z/">
            <span class="flex-auto">GeniusMiaoStudy</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://geniusmiaozz.github.io/post/ccfu-xi/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  C/C++复习总结
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://geniusmiaozz.github.io/post/yi-ge-jian-dan-de-xiao-xing-xiao-yuan-wang-ru-he-she-ji/">
                <h3 class="post-title">
                  一个简单的小型校园网如何设计？
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'd666ec54fdd7e7bcf5a5',
    clientSecret: 'eb4829aff529a141e142de8a677d7b34925325a6',
    repo: 'geniusmiaozz.github.io',
    owner: 'GeniusMiaozz',
    admin: ['GeniusMiaozz'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://geniusmiaozz.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
