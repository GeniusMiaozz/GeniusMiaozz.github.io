<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geniusmiaozz.github.io</id>
    <title>Gridea</title>
    <updated>2020-02-26T02:11:07.940Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geniusmiaozz.github.io"/>
    <link rel="self" href="https://geniusmiaozz.github.io/atom.xml"/>
    <subtitle>GeniusMiao&apos;s blog.</subtitle>
    <logo>https://geniusmiaozz.github.io/images/avatar.png</logo>
    <icon>https://geniusmiaozz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[GeniusMiao-OS各代码文件简要说明]]></title>
        <id>https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/</id>
        <link href="https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/">
        </link>
        <updated>2020-02-25T07:53:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="geniusmiao-os各代码文件简要说明">GeniusMiao-OS各代码文件简要说明</h1>
<blockquote>
<p><strong>markdown文件格式</strong></p>
<p># 一级标题</p>
<p>## 二级标题</p>
<p>&gt; 一级引用文字</p>
<p>&gt;&gt; 二级引用文字</p>
<p>** 粗体文字 **</p>
<p>* 斜体文字 *</p>
<p>*** 斜体加粗文字 ***</p>
<p>~~ 删除线文字 ~~</p>
<p>- * + 列表</p>
<p>***为分割线</p>
</blockquote>
<h2 id="关键概念">关键概念</h2>
<ul>
<li>
<p>保存在磁盘上的操作系统主要分为启动区和程序区，每个区有自己的代码文件及引用的辅助文件（如字体数据、图片等）。主要系统文件通过Makefile文件链接在一起，构成操作系统。</p>
</li>
<li>
<p>一个操作系统其实就是许多二进制数组成的映像文件，一个二进制数可以理解为一个电信号。</p>
</li>
<li>
<p>在整个操作系统中，全局描述符表GDT只有一张（一个CPU对应一个GDT）。GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此积存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。</p>
</li>
</ul>
<h2 id="代码说明">代码说明</h2>
<h3 id="1makefile文件">1.Makefile文件</h3>
<ul>
<li>
<p>DAY_2：创建基础的Makefile文件，包含最基本的制作英雄、汇编、模拟运行、安装至软盘及相关清楚操作。</p>
</li>
<li>
<p>DAY_3：由于拆分了程序区文件，按照高级语言翻译到机器语言的规则（相关见书P60）修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_4：由于新增了OSASK字体信息文件，按照规则修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_6：分隔了Makefile文件，合并了对于后缀名相同、前缀名不同的文件的操作规则，优化代码;：由于新增了程序区文件，按照规则修改了文件，</p>
</li>
</ul>
<h3 id="2启动区代码">2.启动区代码</h3>
<blockquote>
<p><em>0x7c00-0x7dff为规定的启动区内容装载地址。(书P40)</em></p>
<ul>
<li>DAY_3：创建ipl10.nas，当前的整个启动区代码文件。</li>
</ul>
</blockquote>
<h4 id="ipl10nas">ipl10.nas</h4>
<ul>
<li>
<p>DAY_3-读盘，按扇区读依次读入每一个扇区（共计10个扇区），同时完成读入过程中的纠错工作。</p>
<p>启动区读盘完毕后JMP至0xc200号地址处。</p>
</li>
</ul>
<h3 id="3程序区代码">3.程序区代码</h3>
<blockquote>
<p><em>向一个空软盘保存文件时，文件的内容会写在磁盘上0x4200以后的地方。</em></p>
<p><em>磁盘上的内容装载到程序0x8000号地址，所以程序位于内存0x8000+0x4200=0xc200号地址。</em></p>
<p><em><strong>此处包含辅助文件，为了完成操作系统无需编写直接引用的文件。编写的文件标注为创建，引用的文件标注为添加。</strong></em></p>
<p><em><strong>删除线意为此项功能在实际项目中已经完成过，但在后续编写中删掉了该功能或在其基础上对其升级，完成了更高级的功能。</strong></em></p>
<ul>
<li>
<p>DAY_3：创建asmhead.nas，程序区代码的前半部分。</p>
<p>创建bookpack.c，程序区代码的后半部分。</p>
<p>创建naskfunc.nas，汇编完成的部分功能函数。</p>
</li>
<li>
<p>DAY_4：修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_5：添加hankaku.txt文件，OSASK字体信息文件。</p>
<p>修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_6：拆分bootpack.c为三个子文件：</p>
<p>创建graphic.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建dsctbl.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建新的bootpack.c，包含程序区代码的后半部分的主函数。</p>
<p>创建bootpack.h，将函数声明、变量生命、宏定义、头文件引用放置在.h头文件中，优化代码。</p>
<p>创建int.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>修改naskfunc.nas。</p>
</li>
<li>
<p>DAY_7：</p>
</li>
</ul>
</blockquote>
<h4 id="asmheadnas">asmhead.nas</h4>
<ul>
<li>
<p>DAY_3：设定好程序被装载到内存的位置，即ORG 0xc200，完成与启动区的链接。</p>
<p>新增的代码主要为与CPU有关的设定，此处尚未讲解。</p>
</li>
<li>
<p>DAY_4：设定启动区、颜色数目的信息、颜色位数、分辨率的X和Y、图形缓冲区的开始地址， 即完成设置画面模式并把画面模式的信息保存至内存，并用BIOS取得键盘上各种LED指示灯的状态。</p>
</li>
</ul>
<h4 id="naskfuncnas">naskfunc.nas</h4>
<ul>
<li>
<p>DAY_3：利用汇编完成实现暂停CPU功能的函数。</p>
</li>
<li>
<p>DAY_4：利用汇编完成部分函数，并与C函数链接。主要包含：</p>
<p>1.实现不同字节大小的内存写入。</p>
<p>2.中断标志的置位、复位。</p>
<p>3.中断标志位的压栈保存、弹栈读取。</p>
</li>
<li>
<p>DAY_5：利用汇编完成实现对GDTR、IDTR寄存器加载数据的函数。</p>
<p>GDTR与IDTR结构体基本一样。需要取第一个32位数据的低16位和第二个32位数据，合并作为一个48位数据存入寄存器。</p>
<p>MOV		AX,[ESP+6]      取第一个32位数据低16位数据地址<br>
MOV		[ESP+6],AX      第一个32位数据高16位的地址存入其低16位数据<br>
LGDT	[ESP+6]         第一个32位数高16位的地址开始的输入加载至寄存器</p>
</li>
<li>
<p>DAY_6：利用汇编完成中断处理完成之后的“返回”功能，<em><strong>C中的“return”相当于“RET”，此处需要“IRETD”的功能，故采用汇编实现，详见书P120。</strong></em></p>
</li>
</ul>
<h4 id="bookpackc">bookpack.c</h4>
<ul>
<li>
<p>DAY_3：无限调用汇编实现的暂停CPU功能函数，完成一个最基本的操作系统。</p>
</li>
<li>
<p>DAY_4：利用C完成部分函数，并与汇编函数链接。主要包含：</p>
<p>1.实现内存写入，指针实现。</p>
<p><s>2.利用内存写入实现条纹图案。</s></p>
<p><s>3.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</s></p>
<p><s>4.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</s></p>
</li>
<li>
<p>DAY_5：主要完善的功能：</p>
<p><s>1.利用指针保存画面模式信息的值，这些值应与asmhead.nas保持一致。</s></p>
<p>2.利用结构体保存画面模式信息的值，优化代码。</p>
<p>3.利用箭头记号直接获取结构体中成员的值，优化代码。</p>
<p><s>4.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。此处的函数原型：</s></p>
<blockquote>
<p>void putfont8(char *vram, int xsize, int x, int y, char c, char *font);</p>
<p>其中vram是图形缓冲区的开始地址，xsize是分辨率的X，x是绘制图形最左侧的X坐标，y是绘制图形最顶部的Y坐标，c是绘制的颜色，font是绘制图形的数据信息。</p>
</blockquote>
<p><s>5.利用像素点阵的方法，通过对字符数组的遍历，依次绘制每一个字符的图形，从而完成对整个字符串各字符图形的绘制。</s></p>
<p><s>6.利用像素点阵的方法和sprintf函数，以绘制图形的方式输出一个变量及其数值，有助于debug。</s></p>
<p><s>7.利用像素点阵的方法，完成一个鼠标指针图形的绘制。主要过程为：</s></p>
<blockquote>
<p>首先利用init_mouse_cursor8(char *mouse, char bc)，将鼠标图形的像素点颜色信息存入mouse开头的地址中（bc为背景色）。</p>
<p>然后利用void putblock8_8(char *vram, int vxsize, int pxsize,int pysize, int px0, int py0, char *buf, int bxsize)，vram和vxsize是关于VRAM的信息，pxsize和pysize是绘制图形的大小，px0和py0分别是图形左边的X坐标和图形右边的Y坐标，buf是待绘制图形的存放地址，bxsize是待绘制图像分辨率的X即每一行含有的像素数。</p>
</blockquote>
<p><s>8.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</s></p>
</li>
<li>
<p>DAY_6：<em><strong>只保留主函数中对各功能的调用、变量及函数的生命，其余功能函数的具体实现分隔为两个文件graphic.c和dsctbl.c。</strong></em></p>
</li>
</ul>
<h4 id="hankakutxt">hankaku.txt</h4>
<ul>
<li>DAY_5：引入的辅助文件，为OSASK字体数据文件。</li>
</ul>
<h4 id="graphicc">graphic.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</p>
<p>2.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</p>
<p>3.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。</p>
<p>4.利用像素点阵的方法，完成一个鼠标指针图形的绘制。</p>
</li>
</ul>
<h4 id="dsctblc">dsctbl.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</p>
<p>2.完成鼠标和键盘中断处理程序在IDT中的注册，即对段地址、段上限、段属性信息的赋值。</p>
</li>
</ul>
<h4 id="intc">int.c</h4>
<ul>
<li>
<p>DAY_7：主要完善的功能：</p>
<p>1.通过对不同端口的赋值来对PIC（可编程中断控制器）进行初始化，<em><strong>此处相较不易理解，详见书P117。</strong></em></p>
<p>2.利用C和汇编完成处理鼠标（IRQ12）和键盘（IRQ1）的中断，即中断发生时需要调用的程序。<em><strong>此处还需要处理IRQ7的中断处理程序，详见书P119。</strong></em></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://geniusmiaozz.github.io/post/hello-gridea/</id>
        <link href="https://geniusmiaozz.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>