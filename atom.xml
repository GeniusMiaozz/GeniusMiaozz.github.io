<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geniusmiaozz.github.io</id>
    <title>GeniusMiao&apos;s blog.</title>
    <updated>2020-03-01T13:03:56.438Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geniusmiaozz.github.io"/>
    <link rel="self" href="https://geniusmiaozz.github.io/atom.xml"/>
    <subtitle>while(1)
time++;</subtitle>
    <logo>https://geniusmiaozz.github.io/images/avatar.png</logo>
    <icon>https://geniusmiaozz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, GeniusMiao&apos;s blog.</rights>
    <entry>
        <title type="html"><![CDATA[30天自制操作系统-OSCodeFile学习笔记(1-7天内容)]]></title>
        <id>https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/</id>
        <link href="https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/">
        </link>
        <updated>2020-02-25T07:53:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="30天自制操作系统-oscodefile学习笔记1-7天内容">30天自制操作系统-OSCodeFile学习笔记(1-7天内容)</h1>
<p>👉整篇阅读时间约12分钟</p>
<h2 id="关键概念">关键概念</h2>
<ul>
<li>
<p>保存在磁盘上的操作系统主要分为启动区和程序区，每个区有自己的代码文件及引用的辅助文件（如字体数据、图片等）。主要系统文件通过Makefile文件链接在一起，构成操作系统。</p>
</li>
<li>
<p>一个操作系统其实就是许多二进制数组成的映像文件，一个二进制数可以理解为一个电信号。</p>
</li>
<li>
<p>在整个操作系统中，全局描述符表GDT只有一张（一个CPU对应一个GDT）。GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此积存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。</p>
</li>
<li>
<p>如何令操作系统对鼠标与键盘这些外设的活动做出响应？首先要对GDT、IDT初始化，即将数据排列在内存的某个地方，然后将这个地方在内存中的位置的起始地址和有效设定个数写入GDTR/IDTR寄存器；然后PIC进行初始化，使CPU能够接受来自不同地方的中断信号；然后完成鼠标和键盘在IDT中的注册，如果鼠标键盘进行操作发生了中断，CPU会自动调用中断函数进行处理。</p>
</li>
</ul>
<h2 id="代码说明">代码说明</h2>
<h3 id="1makefile文件">1.Makefile文件</h3>
<ul>
<li>
<p>DAY_2：创建基础的Makefile文件，包含最基本的制作英雄、汇编、模拟运行、安装至软盘及相关清楚操作。</p>
</li>
<li>
<p>DAY_3：由于拆分了程序区文件，按照高级语言翻译到机器语言的规则（相关见书P60）修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_4：由于新增了OSASK字体信息文件，按照规则修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_6：分隔了Makefile文件，合并了对于后缀名相同、前缀名不同的文件的操作规则，优化代码;：由于新增了程序区文件，按照规则修改了文件，</p>
</li>
</ul>
<h3 id="2启动区代码">2.启动区代码</h3>
<blockquote>
<p><em>0x7c00-0x7dff为规定的启动区内容装载地址。(书P40)</em></p>
<ul>
<li>
<p>DAY_3</p>
<p>创建ipl10.nas，当前的整个启动区代码文件。</p>
</li>
</ul>
</blockquote>
<h4 id="ipl10nas">ipl10.nas</h4>
<ul>
<li>
<p>DAY_3：读盘，按扇区读依次读入每一个扇区（共计10个扇区），同时完成读入过程中的纠错工作。</p>
<p>启动区读盘完毕后JMP至0xc200号地址处。</p>
</li>
</ul>
<h3 id="3程序区代码">3.程序区代码</h3>
<blockquote>
<p><em>向一个空软盘保存文件时，文件的内容会写在磁盘上0x4200以后的地方。</em></p>
<p><em>磁盘上的内容装载到程序0x8000号地址，所以程序位于内存0x8000+0x4200=0xc200号地址。</em></p>
<p><em><strong>此处包含辅助文件，为了完成操作系统无需编写直接引用的文件。编写的文件标注为创建，引用的文件标注为添加。</strong></em></p>
<p><em><strong>删除线意为此项功能在实际项目中已经完成过，但在后续编写中删掉了该功能或在其基础上对其升级，完成了更高级的功能。</strong></em></p>
<ul>
<li>
<p>DAY_3</p>
<p>创建asmhead.nas，程序区代码的前半部分。</p>
<p>创建bookpack.c，程序区代码的后半部分。</p>
<p>创建naskfunc.nas，汇编完成的部分功能函数。</p>
</li>
<li>
<p>DAY_4</p>
<p>修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_5</p>
<p>添加hankaku.txt文件，OSASK字体信息文件。</p>
<p>修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_6</p>
<p>拆分bootpack.c为三个子文件：</p>
<p>创建graphic.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建dsctbl.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建新的bootpack.c，包含程序区代码的后半部分的主函数。</p>
<p>创建bootpack.h，将函数声明、变量生命、宏定义、头文件引用放置在.h头文件中，优化代码。</p>
<p>创建int.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>修改naskfunc.nas。</p>
</li>
<li>
<p>DAY_7</p>
<p>创建fifo.c，包含自制FIFO缓冲区主要功能函数。</p>
<p>修改int.c。</p>
</li>
</ul>
</blockquote>
<h4 id="asmheadnas">asmhead.nas</h4>
<ul>
<li>
<p>DAY_3：设定好程序被装载到内存的位置，即ORG 0xc200，完成与启动区的链接。</p>
<p>新增的代码主要为与CPU有关的设定，此处尚未讲解。</p>
</li>
<li>
<p>DAY_4：设定启动区、颜色数目的信息、颜色位数、分辨率的X和Y、图形缓冲区的开始地址， 即完成设置画面模式并把画面模式的信息保存至内存，并用BIOS取得键盘上各种LED指示灯的状态。</p>
</li>
</ul>
<h4 id="naskfuncnas">naskfunc.nas</h4>
<ul>
<li>
<p>DAY_3：利用汇编完成实现暂停CPU功能的函数。</p>
</li>
<li>
<p>DAY_4：利用汇编完成部分函数，并与C函数链接。主要包含：</p>
<p>1.实现不同字节大小的内存写入。</p>
<p>2.中断标志的置位、复位。</p>
<p>3.中断标志位的压栈保存、弹栈读取。</p>
</li>
<li>
<p>DAY_5：利用汇编完成实现对GDTR、IDTR寄存器加载数据的函数。</p>
<p>GDTR与IDTR结构体基本一样。需要取第一个32位数据的低16位和第二个32位数据，合并作为一个48位数据存入寄存器。</p>
<p>MOV		AX,[ESP+6]      取第一个32位数据低16位数据地址<br>
MOV		[ESP+6],AX      第一个32位数据高16位的地址存入其低16位数据<br>
LGDT	[ESP+6]         第一个32位数高16位的地址开始的输入加载至寄存器</p>
</li>
<li>
<p>DAY_6：利用汇编完成中断处理完成之后的“返回”功能，<em><strong>C中的“return”相当于“RET”，此处需要“IRETD”的功能，故采用汇编实现，详见书P120。</strong></em></p>
</li>
</ul>
<h4 id="bookpackc">bookpack.c</h4>
<ul>
<li>
<p>DAY_3：无限调用汇编实现的暂停CPU功能函数，完成一个最基本的操作系统。</p>
</li>
<li>
<p>DAY_4：利用C完成部分函数，并与汇编函数链接。主要包含：</p>
<p>1.实现内存写入，指针实现。</p>
<p><s>2.利用内存写入实现条纹图案。</s></p>
<p><s>3.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</s></p>
<p><s>4.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</s></p>
</li>
<li>
<p>DAY_5：主要完善的功能：</p>
<p><s>1.利用指针保存画面模式信息的值，这些值应与asmhead.nas保持一致。</s></p>
<p>2.利用结构体保存画面模式信息的值，优化代码。</p>
<p>3.利用箭头记号直接获取结构体中成员的值，优化代码。</p>
<p><s>4.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。此处的函数原型：</s></p>
<blockquote>
<p>void putfont8(char *vram, int xsize, int x, int y, char c, char *font);</p>
<p>其中vram是图形缓冲区的开始地址，xsize是分辨率的X，x是绘制图形最左侧的X坐标，y是绘制图形最顶部的Y坐标，c是绘制的颜色，font是绘制图形的数据信息。</p>
</blockquote>
<p><s>5.利用像素点阵的方法，通过对字符数组的遍历，依次绘制每一个字符的图形，从而完成对整个字符串各字符图形的绘制。</s></p>
<p><s>6.利用像素点阵的方法和sprintf函数，以绘制图形的方式输出一个变量及其数值，有助于debug。</s></p>
<p><s>7.利用像素点阵的方法，完成一个鼠标指针图形的绘制。主要过程为：</s></p>
<blockquote>
<p>首先利用init_mouse_cursor8(char *mouse, char bc)，将鼠标图形的像素点颜色信息存入mouse开头的地址中（bc为背景色）。</p>
<p>然后利用void putblock8_8(char *vram, int vxsize, int pxsize,int pysize, int px0, int py0, char *buf, int bxsize)，vram和vxsize是关于VRAM的信息，pxsize和pysize是绘制图形的大小，px0和py0分别是图形左边的X坐标和图形右边的Y坐标，buf是待绘制图形的存放地址，bxsize是待绘制图像分辨率的X即每一行含有的像素数。</p>
</blockquote>
<p><s>8.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</s></p>
</li>
<li>
<p>DAY_6：主要完善的功能：</p>
<p><em><strong>1.只保留主函数中对各功能的调用、变量及函数的生命，其余功能函数的具体实现分隔为两个文件graphic.c和dsctbl.c。</strong></em></p>
<p>2.修改了PIC的IMR，以便接受来自键盘和鼠标的中断。</p>
</li>
<li>
<p>DAY_7：主要完善的功能：</p>
<p>1.完成等待并检测键盘控制电路准备完毕的功能。</p>
<p>2.完成初始化键盘控制电路的功能。</p>
<p>3.完成激活鼠标的功能。</p>
<p>4.完成从鼠标获取数据的功能，如果二者缓冲区都为空，则执行HLT；如果有任一缓冲区不为空，则优先取键盘缓冲区数据出来显示。</p>
</li>
</ul>
<h4 id="hankakutxt">hankaku.txt</h4>
<ul>
<li>DAY_5：引入的辅助文件，为OSASK字体数据文件。</li>
</ul>
<h4 id="graphicc">graphic.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</p>
<p>2.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</p>
<p>3.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。</p>
<p>4.利用像素点阵的方法，完成一个鼠标指针图形的绘制。</p>
</li>
</ul>
<h4 id="dsctblc">dsctbl.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</p>
<p>2.完成鼠标和键盘中断处理程序在IDT中的注册，即对段地址、段上限、段属性信息的赋值。</p>
</li>
</ul>
<h4 id="intc">int.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.通过对不同端口的赋值来对PIC（可编程中断控制器）进行初始化，<em><strong>此处相较不易理解，详见书P117。</strong></em></p>
<p>2.利用C和汇编完成处理鼠标（IRQ12）和键盘（IRQ1）的中断，即中断发生时需要调用的程序。<em><strong>此处还需要处理IRQ7的中断处理程序，详见书P119。</strong></em></p>
<p><s>3.实现键盘按键发生中断时输出提示信息。</s></p>
</li>
<li>
<p>DAY_7：主要完善的功能：</p>
<p>1.实现多次执行键盘中断的功能。即在一次IRQ1中断发生后，使PIC继续监视IRQ1中断是否发生</p>
<p>2.实现在发生键盘中断时，输出按键编码的功能（从编号为0x0060的设备输入的8位信息是按键编码）。</p>
<p><s>3.利用移送数据实现FIFO（先进先出）缓冲区，能够输出正确的按键编码，避免两个字节的键码值被丢掉后一个。</s></p>
<p><s>4.利用读追赶写的方式实现FIFO缓冲区，当读写至末尾时进行归0处理，避免了数据的移送操作，优化性能。</s></p>
<p>4.完成处理鼠标中断的功能，<em><strong>分别通知从PIC中断IRQ12已完成和主PIC中断IRQ2已完成，书P142。</strong></em></p>
</li>
</ul>
<h4 id="fifoc">fifo.c</h4>
<ul>
<li>
<p>DAY_7：</p>
<p>1.为FIFO缓冲区增加首地址、下一个数据写入地址、写一个数据读出地址、缓冲区总字节数、缓冲区里没有数据的字节数、缓冲区是否溢出的表示结构体信息。</p>
<p>2.完成初始化FIFO缓冲区的功能。</p>
<p>3.完成向FIFO缓冲区传送数据并保存的功能。</p>
<p>4.完成从FIFO缓冲区获得一个字节数据的功能。</p>
<p>5.完成查看当前FIFO缓冲区存放了多少有效数据的功能。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome to my world.]]></title>
        <id>https://geniusmiaozz.github.io/post/about/</id>
        <link href="https://geniusmiaozz.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<h2 id="联系我呀">📬 联系我呀</h2>
]]></content>
    </entry>
</feed>