<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geniusmiaozz.github.io</id>
    <title>GeniusMiao&apos;s blog.</title>
    <updated>2020-04-07T05:56:12.582Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geniusmiaozz.github.io"/>
    <link rel="self" href="https://geniusmiaozz.github.io/atom.xml"/>
    <subtitle>醉梦不知天在水，满船新梦压清河。</subtitle>
    <logo>https://geniusmiaozz.github.io/images/avatar.png</logo>
    <icon>https://geniusmiaozz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, GeniusMiao&apos;s blog.</rights>
    <entry>
        <title type="html"><![CDATA[C/C++复习]]></title>
        <id>https://geniusmiaozz.github.io/post/ccfu-xi/</id>
        <link href="https://geniusmiaozz.github.io/post/ccfu-xi/">
        </link>
        <updated>2020-04-07T05:55:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础数据结构类型内存相关">基础数据/结构/类型/内存相关</h2>
<h3 id="常量2020322">常量（2020.3.22）</h3>
<ul>
<li>
<p>整数常量：前缀 0X 或 0x 代表十六进制，前缀 0 表示八进制，不带前缀默认为十进制；后缀 U/u 代表无符号整数，L/l 代表长整数。</p>
</li>
<li>
<p>字符常量：\a 为警报铃声，\b 为退格键，\f 为换页符，\v 为垂直制表符，\ooo 为一到三位的八进制数，\xhhh ......为一道多个数字的十六进制数。</p>
</li>
<li>
<p>对于常量的定义，多推荐为大写字母的形式。</p>
</li>
</ul>
<h3 id="浮点数2020322">浮点数（2020.3.22）</h3>
<ul>
<li>浮点数的比较不能直接使用 '=' 进行判断，可以使用减法，当差值在精度允许范围内（比如0.0000001）即可视为两个浮点数相等。</li>
</ul>
<h3 id="字符串2020311">字符串（2020.3.11）</h3>
<ul>
<li>对于char str1[] 和 str2[]，如果二者赋值相同，由于 str1 和 str2 初始地址不同，str1 != str2；对于char *str1 和 *str2，如果二者赋值相同，相当于二者指向内存中同一段地址，str1 = str2。</li>
</ul>
<h3 id="指针202036">指针（2020.3.6）</h3>
<ul>
<li>
<p>32 位机器一个指针占 4 字节空间，64 位机器一个指针占8字节空间。</p>
</li>
<li>
<p>数组做为函数的参数传递时，自动退化为同类型指针，指向数组的第一个元素。<em>（2020.3.7）</em></p>
</li>
<li>
<p>指针函数：返回值是某一类型指针的函数，如 int *fun()，该函数返回值为一个地址；函数指针：指向某一函数的指针变量可以调用函数，如 int (*fun)() = &amp; fun1。<em>（2020.3.23）</em></p>
</li>
<li>
<p>指针数组：一个元素均为某一类型指针的的数组，如 int *p[10]，该数组包含是个int类型指针的元素；数组指针：指向数组某个元素地址的指针，如 int (*p) [10]，p指向数组的首地址（首个元素的地址）。<em>（2020.3.23）</em></p>
</li>
</ul>
<h3 id="c中的动态内存分配">C中的动态内存分配</h3>
<ul>
<li>
<p>可以利用四种方法进行动态内存操作：</p>
<blockquote>
<p>1.void *calloc(int num, int size)：在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0 。</p>
<p>2.void free(void *address)：该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</p>
<p>3.void *malloc(int num):在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</p>
<p>4.void *realloc(void \address, int newsize)：该函数重新分配内存，把内存扩展到 newsize。</p>
<p>4.void *memset(void *s, int ch, size_t n)：将 s 中当前位置后面的 n 个字节用 ch 替换并返回s。</p>
</blockquote>
</li>
</ul>
<h3 id="存储类2020322">存储类（2020.3.22）</h3>
<ul>
<li>
<p>存储类定义 C/C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。</p>
</li>
<li>
<p>存储类主要包含四种：auto、register、static、extern。（在关键字部分记录）</p>
</li>
</ul>
<h3 id="位域2020322">位域（2020.3.22）</h3>
<ul>
<li>位域在本质上就是一种结构体类型，只不过其成员按二进制中的每一位分配。</li>
</ul>
<h2 id="函数相关">函数相关</h2>
<h3 id="可变参数的函数2020322">可变参数的函数（2020.3.22）</h3>
<ul>
<li>
<p>该功能在 stdarg.h 头文件中实现。使用该功能的具体步骤可以概括为：</p>
<blockquote>
<p>1.定义一个函数，最后一个参数为省略号，省略号之前的参数是 int，代表了要传递的可变参数的总数。</p>
<p>2.在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</p>
<p>3.使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</p>
<p>4.使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</p>
<p>5.使用宏 va_end 来清理赋予 va_list 变量的内存。</p>
</blockquote>
</li>
</ul>
<h3 id="回调函数2020322">回调函数（2020.3.22）</h3>
<ul>
<li>
<p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单来说：回调函数是由别人的函数执行时调用你实现的函数。</p>
</li>
<li>
<p>一个回调函数的通俗解释，源于<a href="https://www.zhihu.com/answer/13005983">知乎回答</a>：你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</li>
</ul>
<h2 id="面向对象相关">面向对象相关</h2>
<h3 id="对象内存布局202036">对象内存布局（2020.3.6）</h3>
<ul>
<li>
<p>最基本的对象内存计算规则：对象的内存大小为成员变量的内存之和，成员函数不占内存，无成员变量的对象大小为 1 字节。</p>
</li>
<li>
<p>对于一个只包含非静态成员变量和普通成员函数的类，成员函数放在代码区，该类所有对象公有这一个；成员变量放在堆区，该类对象私有，每新建一个对象都回新建一块内存区域。</p>
</li>
<li>
<p>当有类中有虚函数时，会为该类的每一个实例在堆区添加一个指向虚函数表的指针。</p>
</li>
<li>
<p>类中的 static 成员变量不占用内存该类自身实例化对象的内存。<em>（2020.3.22）</em></p>
</li>
</ul>
<h3 id="虚函数202036">虚函数（2020.3.6）</h3>
<ul>
<li>
<p>虚函数讲解：<a href="https://zhuanlan.zhihu.com/p/28530472">知乎文章</a></p>
</li>
<li>
<p>通过对象内存中的 vptr 找到虚函数表 vtbl，表中存放着虚函数的指针，通过该指针找到对应虚函数的实现区域并进行调用。</p>
</li>
<li>
<p>构造函数不可以是虚函数，析构函数可以是虚函数且推荐设置为虚函数。</p>
</li>
</ul>
<h3 id="内存补齐2020322">内存补齐（2020.3.22）</h3>
<ul>
<li>
<p>内存补齐讲解：<a href="https://zhuanlan.zhihu.com/p/32261819">知乎文章</a></p>
</li>
<li>
<p>内存补齐主要遵循两条基本规则：</p>
<p>1、成员变量的偏移量必须为该变量自身大小的整数倍；</p>
<p>2、对象内存的大小为最大成员变量大小的整数倍；</p>
</li>
<li>
<p>宏 #pragma pack (n) 可以强制设定偏移量为 n 或自身内存大小中较小值的整数倍，n 为 1 时即设置为无内存补齐。</p>
</li>
</ul>
<h3 id="类成员函数的前置const与后置const">类成员函数的前置const与后置const</h3>
<ul>
<li>
<p>当 const 在函数名前面的时候修饰的是函数返回值，函数返回一个常量值。</p>
</li>
<li>
<p>当 const 在函数名后面的输给表示是该类的常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作；对于该类的 const 的对象，不能引用非 const 的成员函数（只能引用后置 const 修饰的常成员函数）。</p>
</li>
</ul>
<h2 id="其它">其它</h2>
<h3 id="预处理2020322">预处理（2020.3.22）</h3>
<ul>
<li>
<p>ANSI C预定义了一些宏可以直接使用但不可以修改，包括：</p>
<blockquote>
<p>1.__DATE__：当前日期，一个以 &quot;MMM DD YYYY&quot; 格式表示的字符常量。</p>
<p>2.__TIME__：当前时间，一个以 &quot;HH:MM:SS&quot; 格式表示的字符常量。</p>
<p>3.__FILE__：这会包含当前文件名，一个字符串常量。</p>
<p>4.__LINE__：这会包含当前行号，一个十进制常量。</p>
<p>5.__STDC__：当编译器以 ANSI 标准编译时，则定义为 1。</p>
</blockquote>
</li>
<li>
<p>预处理器运算符</p>
<blockquote>
<p>1.宏延续运算符（\）：一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。</p>
<p>2.字符串常量化运算符（#）：在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。</p>
<p>3.标记粘贴运算符（##）：宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。</p>
<p>4.defined() 运算符：预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。</p>
</blockquote>
</li>
</ul>
<h2 id="cc中的关键字">C/C++中的关键字</h2>
<h3 id="null和nullptr202036">NULL和nullptr（2020.3.6）</h3>
<ul>
<li>在编译时 NULL 会被解释为 0 ，而 nullptr 就代表空指针。</li>
</ul>
<h3 id="delete和delete202036">delete[]和delete（2020.3.6）</h3>
<ul>
<li>
<p>区别讲解：<a href="https://blog.csdn.net/u012936940/article/details/80919880">CSDN文章</a></p>
</li>
<li>
<p>概括的为：对于基本数据类型（如 int）二者无差别，对于自定义类型（通常指类）如果是 new 申请的内存，释放时用 delete；如果是使用 new []申请的内存，释放时要用 delete []。</p>
</li>
</ul>
<h3 id="auto2020322">auto（2020.3.22）</h3>
<ul>
<li>auto 是所有局部变量默认的存储类。auto 只能用在函数内，即 auto 只能修饰局部变量。</li>
</ul>
<h3 id="regiter2020322">regiter（2020.3.22）</h3>
<ul>
<li>
<p>register 用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。</p>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
</li>
</ul>
<h3 id="static2020322">static（2020.3.22）</h3>
<ul>
<li>
<p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
</li>
</ul>
<h3 id="extern2020322">extern（2020.3.22）</h3>
<ul>
<li>
<p>extern 用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。</p>
</li>
</ul>
<h3 id="stdout-stderr">stdout &amp; stderr</h3>
<ul>
<li>
<p>stdout &amp; stderr 默认均为向屏幕输出。</p>
</li>
<li>
<p>当输出重定向至磁盘文件时，stdout 可以重定向到磁盘文件存储二 stderr 不行。</p>
</li>
<li>
<p>对于Linux环境下（<strong>未测验，据网上讲解</strong>）:</p>
<blockquote>
<p>stdout（标准输出），输出方式是行缓冲。输出的字符会先存放在缓冲区，等按下回车键时才进行实际的 I/O 操作。</p>
<p>stderr（标准错误），是不带缓冲的，这使得出错信息可以直接尽快地显示出来。</p>
</blockquote>
</li>
<li>
<p>对于Windows环境下（<strong>已编写程序测验</strong>）：</p>
<blockquote>
<p>stdout 和 stderr 均直接输出，即 stdout 不碰到回车符也会输出。</p>
</blockquote>
</li>
</ul>
<h3 id="size_t2020323">size_t（2020.3.23）</h3>
<ul>
<li>size_t 通常被用于数组索引和循环计数。使用其它类型来进行数组索引操作的程序可能会在某些情况下出错。</li>
</ul>
<h2 id="cc中的内置函数">C/C++中的内置函数</h2>
<h3 id="sizeof202036">sizeof()（2020.3.6）</h3>
<ul>
<li>
<p>对于一个空类型/只有构造函数和析构函数的类型，占用多少内存由编译器决定（VS 中为 1）。</p>
</li>
<li>
<p>对于一个数组，sizeof求整个数组的大小。<em>（2020.3.7）</em></p>
</li>
</ul>
<h3 id="assert-int-expression-202045">assert( int expression )（2020.4.5）</h3>
<ul>
<li>
<p>assert 的作用是先计算表达式 expression，如果其值为假（即为0）那么它先向 <code>stderr</code> 打印一条出错信息,然后通过调用 abort 来终止程序运行。</p>
</li>
<li>
<p>使用 <code>assert</code> 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。</p>
</li>
</ul>
<h2 id="stl相关">STL相关</h2>
<h3 id="vector202037">vector（2020.3.7）</h3>
<ul>
<li>vector每次扩充容量时，新的容量都是前一次的两倍。把之前的数据复制到新的数组中，再释放之前的内存。（时间性能有负面影响）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个简单的小型校园网如何设计？]]></title>
        <id>https://geniusmiaozz.github.io/post/yi-ge-jian-dan-de-xiao-xing-xiao-yuan-wang-ru-he-she-ji/</id>
        <link href="https://geniusmiaozz.github.io/post/yi-ge-jian-dan-de-xiao-xing-xiao-yuan-wang-ru-he-she-ji/">
        </link>
        <updated>2020-04-07T05:53:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="设计要求">设计要求</h2>
<ul>
<li>某大学分为总校和分校，为该校设计校园网，总校有一个局域网共20台计算机，分校由VLAN 划分为两个局域网，分别有10台计算机。该校被分配了一个C类网段210.100.10.0，总校和分校各有一台路由器及一台交换机。请进行网络设计，将总校和分校各个局域网连接起来。 根据要求，设计IP地址分配表，设计网络结构，画出网络拓扑图。根据设计搭建网络结构。配置网络设备，完成网络调试。</li>
</ul>
<h2 id="设计思路">设计思路</h2>
<ul>
<li>
<p>审题发现，题目要求将一个C类IP地址分为三个局域网，首先由两台路由器分出两个局域网，再由一台交换机将其中一个局域网划分为两个局域网。同时考虑到路由器之间也存在一段网络，顾应将此IP地址划分为4个子网，其中分校、总校两台路由器相连，一台三层交换机、一台二层交换机分别与分校、总校的交换机相连，三层交换机划分出分校的两个子网，二层交换机直接连接总校的子网。设n为子网号位数，利用公式：</p>
<figure data-type="image" tabindex="1"><img src="https://geniusmiaozz.github.io/post-images/1586238898103.png" alt="" loading="lazy"></figure>
<p>不难求出子网号位数为3。到这里，基本的设计思路就分析完毕了。</p>
</li>
</ul>
<h2 id="设计总图">设计总图</h2>
<figure data-type="image" tabindex="2"><img src="https://geniusmiaozz.github.io/post-images/1586238819629.png" alt="" loading="lazy"></figure>
<h2 id="配置指令">配置指令</h2>
<ul>
<li>
<p>首先配置总校交换机SwitchA，创建一个vlan并分配指定端口。</p>
<pre><code class="language-SwitchA(config)#vlan">SwitchA(config-vlan)#exit
SwitchA(config)#interface gigabitEthernet0/1//配置1号端口
SwitchA(config-if)#switchport access vlan 10//1号端口加入vlan20
SwitchA(config-if)#exit
SwitchA(config)#interface gigabitEthernet0/24//配置24号端口
SwitchA(config-if)#switchport mode trunk//24号端口设为trunk模式以便备用
SwitchA(config-if)#end
SwitchA(config)#show vlan//检验vlan配置
</code></pre>
</li>
<li>
<p>SwitchA的vlan配置无误后，进入总校路由器Router1的配置。</p>
<pre><code class="language-Router1(config)#interface">Router1(config-subif)#encapsulation dot1q 10//封装802.1Q，指定给Vlan 10
Router1(config-subif)#ip address 210.100.10.33 255.255.255.224//分配给主校网络
Router1(config-subif)#exit
Router1(config)#interface gigabitEthernet0/1//配置1号端口
Router1(config-if)#ip address 210.100.10.65 255.255.255.224//IP
Router1(config-if)#no shutdown//开启端口
Router1(config-if)#end
Router1#show ip interface brief//检验IP地址和接口配置
Router1(config)#ip route 210.100.10.96 255.255.255.224 210.100.10.66//到分校子网1的静态路由
Router1(config)#ip route 210.100.10.128 255.255.255.224 210.100.10.66//到分校子网2的静态路由
Router1(config)#end
Router1#show ip route//检验静态路由配置
Router1#wr//写入配置
</code></pre>
</li>
<li>
<p>此时已经完成了总校的配置，接下来配置分校交换机SwitchB。</p>
<pre><code class="language-SwitchB(config)#vlan">SwitchB(config-vlan)#exit
SwitchB(config)#vlan 20//创建vlan20
SwitchB(config-vlan)#exit
SwitchB(config)#interface gigabitEthernet0/1//配置1号端口
SwitchB(config-if)#switchport access vlan 10//1号端口划入vlan10
SwitchB(config-if)#exit
SwitchB(config)#interface gigabitEthernet0/2//配置2号端口
SwitchB(config-if)#switchport access vlan 20//2号端口划入vlan20
SwitchB(config-if)#exit
SwitchB(config)#interface gigabitEthernet0/24//配置24号端口
SwitchB(config-if)#switchport mode trunk//24号设为共享端口
SwitchB(config-if)#end
SwitchB#show vlan//检验vlan配置
SwitchB的vlan配置无误后，进入分校路由器Router2的配置。
Router2(config)#interface gigabitEthernet0/1//配置1号端口
Router2(config-if)#ip address 210.100.10.66 255.255.255.224//IP
Router2(config-if)#no shutdown//开启端口
Router2(config-if)#exit
Router2(config)#interface gigabitEthernet0/0//配置0号端口
Router2(config-if)#no ip address//无需直接分配IP地址
Router2(config-if)#no shutdown//需要开启端口
Router2(config-if)#exit
Router2(config)#interface gigabitEthernet0/1.10//配置子网1
Router2(config-subif)#encapsulation dot1q 10
//封装802.1Q，指定给Vlan 10
Router2(config-subif)#ip address 210.100.10.97 255.255.255.224//IP
Router2(config-subif)#exit
Router2(config)#interface gigabitEthernet0/1.20//配置子网2
Router2(config-subif)#encapsulation dot1q 20
Router2(config-subif)#ip address210.100.10.129 255.255.255.224//IP
Router2(config-subif)#exit
Router2#show ip interface brief//检验IP地址和接口配置
Router2(config)#ip route 210.100.10.32 255.255.255.224 210.100.10.65//到总校子网的静态路由
Router2(config)#end
Router2#show ip route//检验静态路由配置
Router2#wr//写入配置
</code></pre>
</li>
</ul>
<h2 id="结果验证">结果验证</h2>
<ul>
<li>
<p>此时，所有的软硬件配置都已完成，直接在计算机上设定本机的IP地址、子网掩码、默认网关，然后正确接线之后即可通过 <code>ping</code> 指令进行验证。举例：</p>
<ol>
<li>
<p>总校PC1</p>
<p>IP：210.100.10.35</p>
<p>子网掩码：255.255.255.224</p>
<p>默认网关：255.255.255.33</p>
</li>
<li>
<p>分校PC2</p>
<p>IP：210.100.10.100</p>
<p>子网掩码：255.255.255.224</p>
<p>默认网关：210.100.10.97</p>
</li>
<li>
<p>分校PC3</p>
<p>IP：210.100.10.130</p>
<p>子网掩码：255.255.255.224</p>
<p>默认网关：210.100.10.129</p>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程题，拿下!(第一阶段Day1~Day30)]]></title>
        <id>https://geniusmiaozz.github.io/post/bian-cheng-ti-na-xia-di-yi-jie-duan-day1~day30/</id>
        <link href="https://geniusmiaozz.github.io/post/bian-cheng-ti-na-xia-di-yi-jie-duan-day1~day30/">
        </link>
        <updated>2020-04-07T05:34:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概况总结">概况总结</h2>
<p>第一阶段主要以复习巩固基础知识为主，同时对如何保证代码的可靠质量进行了学习。做题的主要方式为读题审题、理解解析、阅读源码、复现方法。</p>
<h2 id="题目总览">题目总览</h2>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">主要思想</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">赋值运算符函数</td>
<td style="text-align:center">熟悉语言特性，保证编程严谨性</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">数组中重复的数字</td>
<td style="text-align:center">利用一维数组的性质</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">二维数组中的查找</td>
<td style="text-align:center">利用二维数组的性质</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">替换空格</td>
<td style="text-align:center">利用字符串的性质</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">从尾到头打印链表</td>
<td style="text-align:center">利用链表与栈的性质</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">重建二叉树</td>
<td style="text-align:center">利用二叉树前序、中序遍历的性质</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">二叉树的下一个节点</td>
<td style="text-align:center">利用二叉树的性质</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">用两个栈实现队列</td>
<td style="text-align:center">利用栈与队列的性质</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">斐波那契数列</td>
<td style="text-align:center">考虑用递归及循环解决问题</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">旋转数组的最小数字</td>
<td style="text-align:center">利用二分查找法解决问题</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">矩阵中的路径</td>
<td style="text-align:center">利用回溯法</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">机器人的运动范围</td>
<td style="text-align:center">利用回溯法</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">剪绳子</td>
<td style="text-align:center">利用动态规划&amp;贪心算法</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">二进制中 <code>1</code> 的个数</td>
<td style="text-align:center">利用位运算</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">数值的整数次方</td>
<td style="text-align:center">考虑底数指数的符号情况</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">打印从 <code>1</code> 到最大的 <code>n</code> 位数</td>
<td style="text-align:center">考虑 <code>n</code> 较大的情况</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">在 <code>O(1)</code> 时间删除链表节点</td>
<td style="text-align:center">考虑链表长度及待删除节点位置的不同情况</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">删除链表中重复的节点</td>
<td style="text-align:center">考虑重复节点的位置的不同情况</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">正则表达式的匹配</td>
<td style="text-align:center">考虑多种匹配方式的不同情况</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">表示数值的字符串</td>
<td style="text-align:center">考虑一个正确的数值正则表达式设计</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">调整数组顺序使奇数位于偶数前面</td>
<td style="text-align:center">利用快速排序的思想，考虑可扩展的解法</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">链表的倒数第 <code>k</code> 个节点</td>
<td style="text-align:center">寻找规律，考虑链表头节点及链表节点数目的特殊情况</td>
</tr>
</tbody>
</table>
<h2 id="题目小记">题目小记</h2>
<h3 id="1赋值运算符函数">1.赋值运算符函数</h3>
<ul>
<li>
<p>题目内容</p>
<p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p>
<pre><code class="language-C++">class CMyString
{
public:
    CMyString(char *pData = nullptr);
    CMyString(const CMyString &amp;str);
    ~CMyString(void);

    CMyString &amp;operator=(const CMyString &amp;str);
    void Print();

private:
    char *m_pData;
};
</code></pre>
</li>
<li>
<p>解题思路</p>
<p>对于为一个自定类构造赋值运算符函数，解法并不是重点，重点是解决方法中应注意的事项。主要应关注以下几点：</p>
<ol>
<li>
<p>把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。这样能保证能够连续多次赋值。</p>
</li>
<li>
<p>把传入的参数的类型声明为常量引用。这样能够在传入实例时避免调用一次复制构造函数，减少消耗。</p>
</li>
<li>
<p>赋值前释放实例自身已有内存。这样能够避免内存泄漏。</p>
</li>
<li>
<p>如果传入参数和当前实例是同一个实例，直接返回无需进行复制操作。这样能够避免在释放实例自身内存时也释放掉了传入参数的内存。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>对于上述思路，存在如下一种情况：当在delete释放原有实例内存之后，如果此时内存不足将导致后面的new char抛出异常，而在上述思路中这样的异常会导致很严重的问题。</p>
<p>故可以改进一下思路：进行一个if判断，如果传入参数和当前实例不是同一个对象，则新实例化一个对象和当前进行交换，并返回当前实例。<br>
<strong>在这种方法下，如果一切正常运行，新实例化的对象在if作用域结束时会自动调用析构函数，而由于已经发生了指向内存的交换，实际释放的是旧实例的内存，并返回新实例的指针；如果运行出现异常，由于还没有修改原来实例的状态，能够保证异常安全性。</strong></p>
</li>
</ul>
<h3 id="2数组中重复的数字">2.数组中重复的数字</h3>
<ul>
<li>
<p>题目内容</p>
<p>在一个长度为n的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>直接利用一个哈希表来解决这个问题，这种解法的时间复杂度以及空间复杂度均为 <code>O(N)</code>。</p>
</li>
<li>
<p>考虑这个数组的性质：如果这个数组是无重复数字且升序排序的，那么数字 <code>i</code> 应该出现在下标为 <code>i</code> 的位置。如果这个数组有重复数字，那么升序排序之后有些位置的下标 <code>i</code> 和该位置的值则不相等。</p>
</li>
<li>
<p>改进后的解法：遍历这个数组，当扫描到下标为 <code>i</code> 的数字(假设为 <code>number[i]</code>)时，首先比较 <code>number[i]</code> 是否等于 <code>i</code>，如果是，接着扫描下一个数字；如果不是，拿它和下标为 <code>number[i]</code> 的数字(即 <code>number[number[i]]</code>)比较，如果相同则找到了一个重复的数字，如果不相同就把这两个数字进行交换(<code>Swap(number[i],number[number[i]])</code>)。重复这个比较、交换的过程。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>上述解法需要对数组进行修改，如果不能对数组进行修改，可以考虑利用二分查找的思想解题。把 <code>1~n</code> 的数字从中间数字 <code>m</code> 分为两部分，前面一半为 <code>1~n</code> ，后面一半为 <code>m+1~n</code> 。如果前一半的数字数目超过了m，那么代表数组中一定有至少一个重复数字范围在 <code>1~n</code> 内，反之则在 <code>m+1~n</code> 内。不断的缩写查找范围重复这个过程，直到查找范围仅包含一个数字为止。</p>
</li>
</ul>
<h3 id="3二维数组中的查找">3.二维数组中的查找</h3>
<ul>
<li>
<p>题目内容</p>
<p>在一个二维层次中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</li>
<li>
<p>解题思路</p>
<p>先查看数组右上角的数字，如果等于目标数字则返回。如果大于目标数字，则令查找范围的最大列号减一；如果这个数字小于目标数字，则令查找范围的最小行号减一。不断缩小查找范围，直到找到目标数字或查找范围为空。</p>
</li>
</ul>
<h3 id="4替换空格">4.替换空格</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数，把串联中的每个间隔替换成“％20”。例如输入“ We are happy。”，则输出“ We％20are％20happy。”。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>每有一个 <code>' '</code> 变为 <code>'%20'</code> 就会使字符串的长度增加2，根据这个性质，首先遍历一次字符串，得到正确转换后的新字符串长度。</p>
</li>
<li>
<p>定义两个指针，第一个指针指向源字符串的末尾(角标为旧字符串的长度减一)，第二个指针指向转换后字符串的末尾(角标为转换后的字符串长度减一)。不断得同步向前移动两个指针遍历数组：如果第一个指针位置的字符不是 <code>' '</code>，则把该字符复制到第二个指针位置的字符内容；如果第一个指针位置的字符是 <code>' '</code>，令指针一的位置向前移动一次，再依次在指针二的位置填入 <code>'0'</code>、<code>'2'</code>、<code>'%'</code>，每次填入后令指针二的位置向前移动一次。直到指针一位置的下标小于零。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>在合并两个数组或是字符串时，考虑使用从后往前复制的方法可以减少复制次数、优化效率。</p>
</li>
</ul>
<h3 id="5从尾到头打印链表">5.从尾到头打印链表</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>利用栈的思路解题</p>
<p>先遍历一次链表，每扫描到一个节点时将该节点压入栈中。遍历结束之后，不断地打印栈顶节点并弹栈，直到栈中为空为止。</p>
</li>
<li>
<p>利用递归的思路解题</p>
<p>遍历一次链表，每扫描到一个节点时如果该节点的下一个节点非空，递归调用本函数并将函数参数设为当前节点的下一个节点，然后输出当前节点的信息。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>当链表非常长时不适宜使用递归的方法，因为有可能导致函数调用栈溢出。</p>
</li>
</ul>
<h3 id="6重建二叉树">6.重建二叉树</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出原始二叉树并输出它的头节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>假设前序遍历数组的起始及终止位置为 <code>startPreorder</code> 和 <code>endPreorder</code>,<br>
中序遍历数组的起始及终止位置为 <code>startInorder</code> 和 <code>endInorder</code>。</p>
</li>
<li>
<p>首先根据前序遍历第一个节点的值建立根节点，然后在中序遍历中查找根节点的位置，如果没有找到则抛出异常。假设中序遍历数组中根节点的位置为 <code>rootInorder</code>。</p>
</li>
<li>
<p>在中序遍历中，利用 <code>rootInorder - startInorder</code> 求得根节点左子树中序遍历的长度，假设该值为 <code>m</code>。在前序遍历中，除去首元素(根节点)外的前 <code>m</code> 个元素为根节点左子树的前序遍历。</p>
</li>
<li>
<p>类似的，前序遍历中除去前 <code>(m+1)</code> 个元素(除去根节点和根节点左子树的前序遍历)为根节点右子树的前序遍历，中序遍历中根节点右侧的序列为根节点右子树的中序遍历。</p>
</li>
<li>
<p>如果 <code>m</code> 的值大于零，代表当前根节点左子树非空，递归重建左子树；如果 <code>endPreorder - startPreorder</code> 的值大于 <code>m</code> ，则代表根节点的右子树非空，递归重建右子树</p>
</li>
<li>
<p>递归的终止条件：某一次递归调用时传入参数中前序遍历数组的长度、中序遍历数组的长度均为 <code>1</code>，且两个数组的唯一元素值相等，递归结束，返回。</p>
</li>
</ol>
</li>
</ul>
<h3 id="7二叉树的下一个节点">7.二叉树的下一个节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>给定一棵二叉树和其中的一个节点，如何找出中序遍历顺序的下一个节点？前提：树中的节点除了有两个分别指向左右子节点的指针以外，还有一个指向父节点的指针。</p>
</li>
<li>
<p>解题思路</p>
<p>对于一个二叉树中，求一个节点在中序遍历中的下一个节点：</p>
<ol>
<li>
<p>如果这个节点有右子树，那么下一个节点为该节点右子树的最左子节点。</p>
</li>
<li>
<p>如果该节点没有右子树，但是该节点是父节点的左子节点，那么下一个节点为该节点的父节点。</p>
</li>
<li>
<p>如果该节点没有右子树还是父节点的右子节点，那么就要沿着父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，这个节点的父节点就是下一个节点。</p>
</li>
</ol>
</li>
</ul>
<h3 id="8用两个栈实现队列">8.用两个栈实现队列</h3>
<ul>
<li>
<p>题目内容</p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>设两个栈分别为 <code>stack1</code>、<code>stack2</code>。</p>
</li>
<li>
<p>进队列：元素进 <code>stack1</code> 栈。</p>
</li>
<li>
<p>出队列：<code>stack1</code> 中的元素依次出栈，并入 <code>stack2</code> 栈。<code>stack2</code> 栈顶元素出栈为出队列元素。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>用两个队列实现一个栈的方法：</p>
<ol>
<li>
<p>入栈：哪个队列非空入哪个队列。</p>
</li>
<li>
<p>出栈：非空队列中的元素依次出队列并进入另一个队列，最后一个出队列的元素为实际上出栈的元素。</p>
</li>
</ol>
</li>
</ul>
<h3 id="9斐波那契数列">9.斐波那契数列</h3>
<ul>
<li>
<p>题目内容</p>
<p>写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题利用基本的递归方法效率很低，会对若干个值进行反复求解。</p>
</li>
<li>
<p>为了避免重复计算，做一个 <code>n - 2</code> 次的迭代，每次求得当前元素的前两项和，然后更新前两项元素的值即可。</p>
</li>
</ol>
</li>
<li>
<p>扩展思考</p>
<p>一些题目经过思考会发现本质上也是斐波那契数列问题。</p>
<ol>
<li>
<p>青蛙跳台阶问题：一只青蛙一次可以调上一级台阶也可以跳上两级台阶，求该青蛙跳上一个 <code>n</code> 级台阶总共有多少种跳法。</p>
</li>
<li>
<p>矩形覆盖问题：用一个 <code>2*1</code> 的小矩形横着或竖着去覆盖一个 <code>2*8</code> 的大矩形，总共有多少种方法？</p>
</li>
</ol>
</li>
</ul>
<h3 id="10旋转数组的最小数字">10.旋转数组的最小数字</h3>
<ul>
<li>
<p>题目内容</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>利用二分查找的思想解题。分别取首元素位置 <code>index1</code> 和 尾元素位置 <code>index1</code>，同时因为存在将 <code>0</code> 个数字搬到最后面的情况，先去中间元素的位置 <code>indexMid</code> 为0，保证得到正确的结果。</p>
</li>
<li>
<p>以 <code>index1</code> 位置的元素是否大于等于 <code>index2</code> 位置的元素作为条件循环，取 <code>index1</code> 与 <code>index2</code> 中间的元素，如果三个元素相等，则直接对数组遍历来找到最小元素；否则如果 <code>index1</code> 位置的元素小于等于 <code>indexMid</code>位置的元素，则最小数字在数组的后半段，令 <code>index1</code> 等于 <code>indexMid</code>；如果 <code>index2</code> 位置的元素大于等于 <code>indexMid</code> 位置的元素，则最小数字在数组的前半段，令 <code>index2</code> 等于 <code>indexMid</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="11矩阵中的路径">11.矩阵中的路径</h3>
<ul>
<li>
<p>题目内容</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br>
A B T G<br>
C F C S<br>
J D E H</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>利用回溯法解决的典型题。对矩阵中所有的格子挨个进行扫描，如果某个格子中的字符 <code>ch</code> 对应路径中的第 <code>i</code> 个字符，那么在这个相邻的格子寻找路径上的第 <code>i + 1</code> 个字符。不断重复这个过程，直到路径上的所有字符都在矩阵中找到对应的位置。</p>
</li>
<li>
<p>首先应有一个函数初始化一个存储格子是否被访问过信息的数组，并在这个函数中对格子中所有的节点进行扫描，判断从该格子触发是否能找到正确的路径(假设这个调用的判断函数为 <code>fun</code>)。</p>
</li>
<li>
<p>在 <code>fun</code> 函数中，如果当前路径读到的字符已遇到结束符，则代表在矩阵中找到了路径直接返回；否则如果当前传入格子(假设这个格子 为 <code>a</code>)的字符等于当前路径读到的字符，并且 <code>a</code> 这个格子没有被访问过，应该选取 <code>a</code> 这个格子作为下一步的行动路径，更改这个格子的访问信息为 <code>True</code>，然后递归调用 <code>fun</code> 函数检查 <code>a</code> 格子的相邻格子是否有路径中的下一个字符，如果有返回 <code>True</code>，如果没有应回溯一步，将 <code>a</code> 格子的访问信息更改为 <code>False</code>，返回 <code>True</code>进行下一个格子的判断。</p>
</li>
</ol>
</li>
</ul>
<h3 id="12机器人的运动范围">12.机器人的运动范围</h3>
<ul>
<li>
<p>题目内容</p>
<p>地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>从坐标 <code>(0,0)</code> 的位置开始移动，每当进入一个新位置时通过检查坐标的数位来判断机器人是否能够进入，如果能进入再递归判断四个相邻的格子是否能够进入。</p>
</li>
<li>
<p>首先应有一个函数初始化一个存储格子是否被访问过信息的数组，并在这个函数中对 <code>(0,0)</code> 这个位置进行扫描，判断从该初始位置触发最多能到达多少个格子(假设这个调用的统计函数为 <code>fun</code>)。</p>
</li>
<li>
<p>在 <code>fun</code> 函数中了，首先对当前传入的格子进行检查，如果不符合要求代表该格子无法到达，直接返回 <code>0</code>；如果符合要求，首先更改这个格子的访问信息为 <code>True</code>，对于从这个格子出发能够访问到的格子数量为 <code>1</code> 加上从相邻的四个格子能访问到的格子数。</p>
</li>
<li>
<p>考虑边界情况：对于一个边界的格子(该格子依然能到达)，如果它的四个相邻格子由于超出范围、已经访问过、不符合要求条件等原因已经不能再到达，那么该边界格子就会返回 <code>1 + 0 + 0 + 0 + 0</code>,而这个信息会逐层向上传递直到返回给初始格子。</p>
</li>
</ol>
</li>
</ul>
<h3 id="13剪绳子">13.剪绳子</h3>
<ul>
<li>
<p>题目内容</p>
<p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>动态规划的想法</p>
<ol>
<li>
<p>当绳子长度小于 <code>2</code> 时，无剪法，返回零；当绳子长度等于 <code>2</code> 时，返回最大值 <code>1</code>；当绳子长度等于 <code>3</code> 时，返回最大值 <code>2</code>。</p>
</li>
<li>
<p>初始化一个长度为绳子长度的数组 <code>products</code>，前四项分别为 <code>0、1、2、3</code>。从第五项开始逐个扫描直至最后一项，每一项 <code>i</code> 结果最大值 <code>products[i]</code> 为 <code>max(products[j] * products[i - j])</code>，其中 <code>j ∈ 1 ~ i / 2</code>。</p>
</li>
</ol>
</li>
<li>
<p>贪婪算法的想法</p>
<p>利用数学可以证明：当绳子的长度大于 <code>5</code> 时，尽可能多剪长度为 <code>3</code> 的绳子段会使结果值达到最大值；而当剩余绳子长度小于 <code>5</code> 时，剪为两根长度为 <code>2</code> 的绳子达到最大值。</p>
</li>
</ol>
</li>
</ul>
<h3 id="14二进制中-1-的个数">14.二进制中 1 的个数</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>常规思路</p>
<p>设定一个 <code>flag = 1</code>。不断求输入数字 <code>n</code> 与 <code>flag</code> 相与得到的结果，如果结果不为 <code>0</code> 则令计数值 <code>count</code> 加一，这样循环的次数是整数二进制的位数。</p>
</li>
<li>
<p>改进思路</p>
<ol>
<li>
<p>如果把一个二进制表示的整数减去一，都是把最右边的 <code>1</code> 变成 <code>0</code>，如果它的右边还有 <code>0</code>，就把这些 <code>0</code> 全变成 <code>1</code>。</p>
</li>
<li>
<p>故可以发现：把输入数字 <code>n</code> 与 <code>n - 1</code> 进行与运算并赋值给 <code>n</code>，相当于把 <code>n</code> 中的最低位的 <code>1</code> 变为 <code>0</code> 而其他位保持不变。基于这种思路的解法，循环次数为 <code>n</code> 的二进制表示中 <code>1</code> 的个数。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="15数值的整数次方">15.数值的整数次方</h3>
<ul>
<li>
<p>题目内容</p>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>这道题的关键之一就是确保代码的完整性。如果传入的底数为 <code>0</code>，直接返回 <code>0</code> 即可。</p>
</li>
<li>
<p>对于指数为负数的情况，应当首先对指数取绝对值，然后对计算的结果取倒数；对于指数为正数的情况直接调用函数计算结果皆可。</p>
</li>
<li>
<p>如何完成一个函数计算底数的指数次幂：当指数为 <code>0</code> 时，返回 <code>1</code>；当指数为 <code>1</code> 时，返回底数；否则递归调用本函数计算当前传入参数中底数的(指数 / 2)次幂，对该结果做平方，如果指数为计数再令该结果乘上一次底数并复制给自身，然后返回该结果。</p>
</li>
</ol>
</li>
</ul>
<h3 id="16打印从1到最大的n位数">16.打印从1到最大的n位数</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>在字符串上模拟数字加法的思路</p>
<ol>
<li>
<p>首先初始化一个长度为 <code>n + 1</code> 的字符串，用来存放 <code>n</code> 位数字的每一位及字符串的终止符 <code>\0</code>。通过函数 <code>fun1</code> 来对字符串模拟整数加一的操作并判断当前是否已累加至最大数字，然后通过函数 <code>fun2</code> 来打印信息。</p>
</li>
<li>
<p>在 <code>fun1</code> 的执行过程中，从字符串(假设为 <code>number</code>)的最低位(假设为 <code>i = length - 1</code>)开始依次取单个数字，每次取数字后应直接加上前一位传来的进位标志位，即 <code>nSum = number[i] - '0' + nTakeOver</code>。当取到的数字为最低位时，应执行加一操作，首先令 <code>nSum</code> 加一。</p>
</li>
<li>
<p>然后判断 <code>nSum</code> 的值，如果 <code>nSum &gt;= 10</code> 且当前位为最高位(<code>i = 0</code>)，代表已累加至 <code>n</code> 位数最大值，返回 <code>True</code>；如果当前位不是最高位，由于产生了进位，应置这一位的值归零，同时置进位标志位为 <code>1</code> 以使高一位的值加一。</p>
</li>
<li>
<p>如果 <code>nSum &lt; 10</code> ，代表本次加一的操作正常执行且没有发生进位，此时直接返回 <code>False</code>。</p>
</li>
<li>
<p>在 <code>fun2</code> 的执行过程中，应该从左到右逐个字符扫描字符串，当碰到第一个非 <code>0</code> 的字符之后开始打印，直至字符串的结尾。</p>
</li>
</ol>
</li>
<li>
<p>基于递归的数字排列思路</p>
<ol>
<li>
<p>首先初始化一个长度为 <code>n + 1</code> 的字符串，用来存放 <code>n</code> 位数字的每一位及字符串的终止符 <code>\0</code>。首先对字符串的最高位(<code>i = 0</code>)进行 <code>0 ~ 9</code> 的枚举，对于对于每种情况调用函数 <code>fun</code> 来进行处理。</p>
</li>
<li>
<p>在 <code>fun</code> 函数中首先判断传入参数中当前选中位是否为最低位(<code>if(index == length - 1)</code>)，如果为最低位调用 <code>fun2</code> 函数输出数字；否则对当前选中位的低一位(<code>index + 1</code>)进行 <code>0 ~ 9</code> 的枚举，递归调用 <code>fun</code> 函数处理。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="17在o1时间删除链表节点">17.在O(1)时间删除链表节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>如果要删除的节点不是尾节点(代表链表中至少有两个节点)，首先获取待删除节点(<code>pNeedDel</code>)的下一个节点(<code>pNext = pNeedDel -&gt; next</code>)，将下一个节点值的信息赋值给待删除的节点(<code>pNeedDel -&gt; value = pNext -&gt; value</code>)，然后将待删除节点的下一节点指针指向下一节点的下节点(<code>pNeedDel -&gt; next = pNext -&gt; next</code>)。最后删除下一节点(<code>pNext</code>)的内存，令该指针指向空。</p>
</li>
<li>
<p>如果当前链表只有一个节点，直接删除待删除的节点，令待删除节点的指针及头节点的指针指向空。</p>
</li>
<li>
<p>如果链表中有多个节点且待删除节点为尾节点，此时就需要从头遍历链表，找到尾节点的地址后再进行删除。</p>
</li>
</ol>
</li>
</ul>
<h3 id="18删除链表中重复的节点">18.删除链表中重复的节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>在一个排序的链表中，设计一个函数，删除所有重复的节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>由于头节点也有可能被删除，因此传入的参数应设为 <code>ListNode **pHead</code> 而不是 <code>ListNode *pHead</code>。</p>
</li>
<li>
<p>从头到尾遍历整个链表。如果当前节点的值与下一个节点的值相同，那么他们就是重复的节点，此时应将所有连续的重复节点删除，并保证当前节点的前一个节点与后边值比当前节点的值大的第一个节点相连。重复这个过程直到遍历到链表的最后一个节点。</p>
</li>
</ol>
</li>
</ul>
<h3 id="19正则表达式的匹配">19.正则表达式的匹配</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数用来匹配包含'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;及&quot;ab*a&quot;均不匹配。</p>
</li>
<li>
<p>解题思路</p>
<p>在匹配的过程中，主要进行如下几种判断：</p>
<ol>
<li>
<p>如果当前字符串与模式读到的字符均为 <code>\0</code>，则整个字符串与表达式匹配成功返回 <code>True</code>。</p>
</li>
<li>
<p>如果当前字符串读到的字符不是 <code>\0</code> 而模式读到的字符为 <code>\0</code>，代表表达式未完全匹配整个字符串，字符串与表达式匹配失败返回 <code>False</code>。</p>
</li>
<li>
<p>如果模式中当前读入字符的下一个字符为 <code>*</code>，即能匹配任意个字符，则首先判断字符串及模式中的当前读入字符是否能匹配(即两个字符相等或字符串的当前读入字符不等于 <code>\0</code> 且模式的当前读入字符为 <code>'.'</code>)。</p>
<ul>
<li>
<p>如果能匹配，则针对下一个字符 <code>'*'</code> 有三种情况：</p>
<ol>
<li>
<p>在模式上向后移动两个字符，即忽略当前读入字符与下一个字符 <code>'*'</code> 的匹配。</p>
</li>
<li>
<p>在字符串上向后移动一个字符，模式上向后移动两个字符，即当前读入字符与下一个字符 <code>'*'</code> 匹配字符串中的一个字符。</p>
</li>
<li>
<p>字符串上向后移动一个字符，模式上向后移动零个字符，即当前读入字符与下一个字符 <code>'*'</code> 匹配字符串中的若干个字符。</p>
</li>
</ol>
</li>
<li>
<p>如果不能匹配，则针对下一个字符 <code>'*'</code> 只有一种情况：在模式上向后移动两个字符，即忽略当前读入字符与下一个字符 <code>'*'</code> 的匹配。</p>
</li>
</ul>
</li>
<li>
<p>如果模式中当前读入字符的下一个字符不是 <code>*</code>，则判断字符串及模式中的当前读入字符是否能匹配(即两个字符相等或字符串的当前读入字符不等于 <code>\0</code> 且模式的当前读入字符为 <code>'.'</code>)。如果匹配，则字符串上向后移动一个字符，模式上向后移动一个字符继续匹配。</p>
</li>
<li>
<p>所有其他情况均返回 <code>False</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="20表示数值的字符串">20.表示数值的字符串</h3>
<ul>
<li>
<p>题目内容</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都表示数值，但“12e”、“1a3.14”、“1.2.3”、“+-5”及“12e+5.4”都不是。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>首先先扫描整数部分的正负号(<code>'+'</code> 或者 <code>'-'</code>)，正负号可能有也可能没有，如果有则匹配并定位字符串中的下一个字符。</p>
</li>
<li>
<p>然后尽可能多得匹配一个以 <code>0 ~ 9</code> 中数字构成的数字串，这一部分是数字的整数部分。如果整数部分匹配到了至少一个数字，此时返回一个初步结果 <code>True</code>，因为单纯的整数也是一个合理的数值。</p>
</li>
<li>
<p>接下来如果遇到小数点 <code>'.'</code>，尝试去匹配一个以 <code>0 ~ 9</code> 中数字构成的数字串，即小数点后面的小数部分。此时求得中间结果为初步结果与这一步结果的或运算值，因为一个小数可以没有整数部分(<code>.123</code>)、小数点后面也可以没有数字(<code>123.</code>)、或者小数点前面和后面均有数字(<code>123.123</code>)。</p>
</li>
<li>
<p>接下来如果遇到指数标志 <code>'e'</code> 或 <code>'E'</code>,尝试去匹配一个以 <code>'+'</code> 或者 <code>'-'</code> 开头(可以没有这个符号位)，其余以 <code>0 ~ 9</code> 中数字构成的数字串，即指数的数值。此时求得最终结果为中间结果与这一步结果的与运算值。因为指数标志 <code>'e'</code> 或 <code>'E'</code> 前面没有数字时整个字符串不能表示数字，而后面没有整数时也不能表示数字。</p>
</li>
<li>
<p>最终返回最终结果和当前字符串读入字符等于 <code>\0</code> 的与运算值，因为如果成功匹配了一个数值之后如果后面还有奇异字符依然为匹配失败。</p>
</li>
</ol>
</li>
</ul>
<h3 id="21调整数组顺序使奇数位于偶数前面">21.调整数组顺序使奇数位于偶数前面</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</li>
<li>
<p>解题思路</p>
<p>这道题可以直接利用快速排序的思想解题，分别用两个指针定位数组的首尾步，首指针向后移动，尾指针向前移动，每当首指针遇到一个偶数、尾指针遇到一个奇数停止移动，交换两个数，继续移动指针。重复这个过程，直到首指针的位置不小于尾指针的位置为止。</p>
</li>
<li>
<p>扩展思考</p>
<p>对于题中“判断遇到的数为奇数还是偶数”这一项，可以额外的增加一个函数专用来返回奇偶结果的判断值，这样在需要进行扩展修改时(如将所有偶数调整至奇数前面)可以很便捷地进行扩展。</p>
</li>
</ul>
<h3 id="22链表的倒数第k个节点">22.链表的倒数第k个节点</h3>
<ul>
<li>
<p>题目内容</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如一个链表有6个节点，从头节点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
</li>
<li>
<p>解题思路</p>
<ol>
<li>
<p>定义两个指针，第一个指针从链表的头指针开始遍历向前走 <code>k - 1</code> 步，第二个指针保持不动；从 <code>k</code> 步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针保持 <code>k - 1</code> 的距离，当第一个指针走到链表尾部的时候，第二个指针的位置为 <code>n - k + 1</code>，即倒数第 <code>k</code> 个节点。</p>
</li>
<li>
<p>本体需要考虑几种特殊情况：输入的头指针为空指针，应直接返回空指针；当链表节点数少于 <code>k</code> 时，应在前 <code>k - 1</code> 步时每一步判断下一节点是否为空指针；<code>k</code> 值为 <code>0</code>，应直接返回空指针。</p>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[看了这段代码，我……]]></title>
        <id>https://geniusmiaozz.github.io/post/ni-jian-guo-zhe-yang-de-dai-ma-ma/</id>
        <link href="https://geniusmiaozz.github.io/post/ni-jian-guo-zhe-yang-de-dai-ma-ma/">
        </link>
        <updated>2020-03-07T09:47:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="长见识了">长见识了..</h1>
<p>前两天刷知乎时看到这样一行代码：</p>
<p><strong>char *(*c[10])(int **p);</strong></p>
<p>当时我的大脑中是这样的：</p>
<figure data-type="image" tabindex="1"><img src="https://geniusmiaozz.github.io/post-images/1583574662322.png" alt="" loading="lazy"></figure>
<p>随之我的大脑中是这样的：</p>
<p>*c[10]我记得是一个指针数组，数组中的元素为指针；后面括号中的内容只能是参数了，参数为一个int类型的二重指针？那前面的char *呢。。</p>
<p>上网求解之后我的大脑又变成了这样的：</p>
<figure data-type="image" tabindex="2"><img src="https://geniusmiaozz.github.io/post-images/1583574683219.jpg" alt="" loading="lazy"></figure>
<hr>
<p>题解+个人总结：</p>
<ul>
<li>
<p>首先，c[10]是一个数组。</p>
</li>
<li>
<p>在前面加上一个*，*c[10]是一个指针数组，数组中元素的类型为指针；如果是(*c)[10]，则为一个数组指针，c这个指针指向一个元素个数为10的数组的首地址。</p>
</li>
<li>
<p>紧接着，由于加上了参数，(*c[10])(int **p)是一个函数指针的数组，函数有一个int **p二重指针作为形参。</p>
</li>
<li>
<p>最后，char *(*c[10])(int **p)代表：c是一个数组，该数组用于存放一个形参为整型二重指针、返回值为字符串的函数的函数指针。</p>
</li>
</ul>
<p>再附上一段网上给出的代码：</p>
<pre><code class="language-c++">char *(*c[10])(int **p);
char *fun(int **p)
{
    return &quot;hello\n&quot;;
}
int main()
{
	c[0] = fun;
	printf(&quot;%s&quot;, c[0](NULL));
	return 0;
}
</code></pre>
<p>亲测的运行结果：<img src="https://geniusmiaozz.github.io/post-images/1583574463792.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是软件过程？]]></title>
        <id>https://geniusmiaozz.github.io/post/ruan-jian-gong-cheng-zhong-guo-cheng-de-gai-nian/</id>
        <link href="https://geniusmiaozz.github.io/post/ruan-jian-gong-cheng-zhong-guo-cheng-de-gai-nian/">
        </link>
        <updated>2020-03-04T16:02:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="软件过程的定义">软件过程的定义</h1>
<p><strong>软件过程由开发或维护软件及其相关产品的一系列活动构成，这些活动从不同的方面定义了软件开发中的步骤、交付物、涉众及其职责等流程要素。</strong></p>
<h1 id="为什么要引入软件过程">为什么要引入软件过程？</h1>
<ul>
<li>
<p>软件工作的范围从只考虑编写程序扩展到需要考虑整个软件生存周期。</p>
</li>
<li>
<p>软件的开发风险从曾经的少、可预知、可控制演变到多、不易预知、不易控制。</p>
</li>
<li>
<p>软件开发的角色从程序员扩展到需要团队中更多的角色。</p>
</li>
<li>
<p>软件标准从软件产品的标准化扩展到软件开发过程的标准化。</p>
</li>
</ul>
<h1 id="软件过程的实现">软件过程的实现</h1>
<p><strong>一个软件的生命周期分为软件定义、软件开发、软件维护三个周期，整个过程包含基本活动及辅助性活动。软件过程通过三个“IN”：输入，如需求；资源，如人力、工具；控制，如预算、时间表、规范标准，最终完成一个“OUT”如程序代码、程序文档。</strong></p>
<h1 id="活动的概念">活动的概念</h1>
<ul>
<li>
<p>基础活动</p>
<p>主要包含问题定义，需求，规约，设计，实现，软件验证，集成，软件演进/维护，退役等。</p>
</li>
<li>
<p>辅助性活动</p>
<p>软件项目跟踪和控制，正式的技术复审，软件质量保证，软件配置管理，文档编制，服用管理，度量，风险管理等。</p>
</li>
</ul>
<h1 id="活动详解">活动详解</h1>
<h2 id="问题定义活动">问题定义活动</h2>
<ul>
<li>
<p>What</p>
<p>定义要解决的问题，并确定系统范围。</p>
</li>
<li>
<p>Why</p>
<p>形成初步的早起判断，达成最初共识。</p>
</li>
<li>
<p>When</p>
<p>在项目日程表的最前端，占整个开发时间中的比例很小。</p>
</li>
<li>
<p>Who</p>
<p>由系统分析师、出资方领导、出资方技术人员、开发方领导和项目经理定义。</p>
</li>
<li>
<p>Where</p>
<p>客户现场。</p>
</li>
<li>
<p>How<br>
<img src="https://geniusmiaozz.github.io/post-images/1583337862318.jpg" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="可行性研究活动">可行性研究活动</h2>
<ul>
<li>
<p>What</p>
<p>以相对短的时间和相对低的成本来确定给定的问题在其约束条件内是否有解、有几种解以及哪个是最佳解。</p>
</li>
<li>
<p>Why</p>
<p>确立满足约束条件的方案是否存在、是否可行、是否最优，然后才能在最优方案的基础上进行开发、</p>
</li>
<li>
<p>When</p>
<p>在项目的早期阶段，占整个开发时间中的比例较小。</p>
</li>
<li>
<p>Who</p>
<p>由系统分析师、出资方领导、出资方技术人员、开发方领导、项目经理、架构设计师、市场人员、软件质量保证人员等研究。</p>
</li>
<li>
<p>Where</p>
<p>客户现场。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://geniusmiaozz.github.io/post-images/1583338118988.jpg" alt="" loading="lazy"></figure>
<h2 id="需求分析活动">需求分析活动</h2>
<ul>
<li>
<p>What</p>
<p>通过五点来描述：</p>
<ul>
<li>
<p>需求：主要是在产品构建之前确定的系统必须符合的条件或具备的功能，它们是关于系统将要完成什么工作的一段描述语句，它们必须经过所有相关人员的认可，其目的是彻底地解决客户的问题。</p>
</li>
<li>
<p>需求文档：一组需求的集合，分为用户需求文档、系统需求文档和软件规约文档</p>
</li>
<li>
<p>功能性需求：描述了系统应该做什么，即具备的功能或服务。（输入、输出和计算等）</p>
</li>
<li>
<p>非功能性需求：描述了系统必须遵守的约束条件。（响应时间、吞吐量、可靠性、可移植性、可扩展性、易用性、安全性、资源要求、可复 用性、技术要求、文化和政策需求、法律需求、道德要求、隐私要求，等等）</p>
</li>
<li>
<p>描述需求的标准：是完整的、正确的、必要的、无歧义的、可行的、可验证的以及被设置了优先级别的。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>六个错误：</p>
<ul>
<li>
<p>需求不一致、模糊、矛盾</p>
</li>
<li>
<p>需求变更</p>
</li>
<li>
<p>客户忽略领域常识/知识/术语</p>
</li>
<li>
<p>客户集中于现有系统的不足之处，而忽略了系统要实现的关键功能</p>
</li>
<li>
<p>零碎、无组织、不明确、表达不清</p>
</li>
<li>
<p>不分轻重缓急</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>贯穿于整个软件开发过程，早起工作量大后逐渐减少。</p>
</li>
<li>
<p>Who</p>
<p>系统分析师、需求阐释者、客户代表、用户代表、开发方领导、项目经理、架构设计师、领域专家、财务人员、市场人员、软件质量保证（SQA，Software Quality Assure）人员、程序员、测试人员、部署人员、技术文档编写人员、培训人员等。</p>
</li>
<li>
<p>Where</p>
<p>三种情况：</p>
<ul>
<li>
<p>调研时，在客户现场</p>
</li>
<li>
<p>编纂软件需求规约文档时，可以在开发单位</p>
</li>
<li>
<p>复审相关的需求文档时，根据需要来安排</p>
</li>
</ul>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://geniusmiaozz.github.io/post-images/1583338131488.jpg" alt="" loading="lazy"></figure>
<h2 id="设计活动">设计活动</h2>
<ul>
<li>
<p>What</p>
<p>通过四个方面来描述：</p>
<ul>
<li>
<p>设计：是在系统的约束条件下（如预算、时间、人力资源、用户软、硬件环境和用户对系统的操作能力等），为了实现系统的功能性需求和非功能性需求，而找到并描述的一种遵循高质量的通用原则的方法，其交付文档能够指导开发人员实现系统。</p>
</li>
<li>
<p>总体设计：任务是根据软件需求规约文档，确定一个合理的软件体系结构。这个体系结构包括合理地划分组成系统的模块、模块间的调用关系以及模块间的接口关系。软件体系结构还从总体方面决定了系统的可扩充性、可维护性，以及系统的性能等。总体设计的设计粒度较大，有时也被称为概要设计、架构设计。</p>
</li>
<li>
<p>详细设计：详细设计地任务是在总体设计的基础上进一步确定如何实现目标系统，包括系统的数据对象的设计、人机接口的设计以及模块逻辑的详细设计。</p>
</li>
<li>
<p>设计部件的粒度：系统、子系统、框架、构件、组件、模块、类、 方法等。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>主要包含：</p>
<ul>
<li>
<p>软件架构是软件系统的核心</p>
</li>
<li>
<p>应对复杂多变的情况，同时保持完整性</p>
</li>
<li>
<p>应对系统在扩展功能当中出现的问题</p>
</li>
<li>
<p>大规模复用的有效基础</p>
</li>
<li>
<p>项目管理的基础</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>贯穿于整个软件开发过程的设计活动。</p>
</li>
<li>
<p>Who</p>
<p>主要包括架构设计师、软件设计员、复用工 程师、设计复审员、项目经理、财务人员、 软件质量保证（SQA，Software Quality Assure）人员和需求变更者等。</p>
</li>
<li>
<p>Where</p>
<p>建议在软件企业内部进行设计。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://geniusmiaozz.github.io/post-images/1583338157712.jpg" alt="" loading="lazy"></figure>
<h2 id="实施活动">实施活动</h2>
<ul>
<li>
<p>What</p>
<p>三个方面：</p>
<ul>
<li>
<p>编码：是将软件设计结果转换成用某种程序设计语言书写的程序。</p>
</li>
<li>
<p>单元测试：是把一个模块作为独立的程序单元进行测试，以保证它能够正确执行规定的功能。</p>
</li>
<li>
<p>集成：是指将单独的软件构件合并成一个整体的软件系统。集成分为集成子系统和集成系统两个级别。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>两个极端：</p>
<ul>
<li>以实施为中心的软件开发</li>
</ul>
<p>弱化的需求，弱化的设计。对实施人员的过度依赖。</p>
<ul>
<li>对实施活动的轻视</li>
</ul>
<p>需要的时间进入工作状态，具有技术含量，水平存在差异，实施质量不易度量</p>
</li>
<li>
<p>When</p>
<p>项目的中、后期阶段。</p>
</li>
<li>
<p>Who</p>
<p>包括实施员、代码复审员、集成员、测试工程师、测试员、项目经理、架构设计师、软件设计员、复用工程师、SQA人员和财务人员等</p>
</li>
<li>
<p>Where</p>
<p>建议在软件企业内部进行开发。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://geniusmiaozz.github.io/post-images/1583338166171.jpg" alt="" loading="lazy"></figure>
<h2 id="测试活动">测试活动</h2>
<ul>
<li>
<p>What</p>
<p>通过七个方面来描述：</p>
<ul>
<li>
<p>测试：是选择适当的测试用例执行被测程序的过程，其目的在于发现程序错误。</p>
</li>
<li>
<p>缺陷：是系统任一方面（包括需求、设计或代码）的缺点。该缺点会促成或潜在的促成一个或多个失败发生。</p>
</li>
<li>
<p>错误：是指程序中的缺陷所产生的不正确结果。</p>
</li>
<li>
<p>失败：当一个程序不能运行或者其表现不可被接受时称为失败。失败是系统执行中出现的情况。失败源于代码 缺陷。</p>
</li>
<li>
<p>主要包含6种测试活动：单元测试、集成测试、系统测试、α测试、β测试、验收测试。</p>
</li>
<li>
<p>质量维度：描述质量的概念或评测质量的方法的不同视角。</p>
</li>
<li>
<p>测试用例：为特定目标开发的测试输入、执行条件和预期结果的集合。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>三方面：</p>
<ul>
<li>
<p>及时检查出项目中的缺陷和不足。</p>
</li>
<li>
<p>保证所开发的软件能够达到用户满意。</p>
</li>
<li>
<p>测试是项目管理的重要内容。</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>贯穿于软件整个生命周期中。</p>
</li>
<li>
<p>Who</p>
<p>主要包括测试工程师、测试员、软件设计员、实施员、项目经理、部署工程师、部署员、SQA人员和财务人员等。</p>
</li>
<li>
<p>Where</p>
<p>建议单元测试、集成测试和系统测试在实施员所在的开发现场及其附近进行，β测试和验收测试则完全在用户现场测试。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://geniusmiaozz.github.io/post-images/1583338176023.jpg" alt="" loading="lazy"></figure>
<h2 id="部署活动">部署活动</h2>
<ul>
<li>
<p>What</p>
<p>通过四个方面来描述：</p>
<ul>
<li>
<p>部署：是为确保最终用户可以正常使用软件产品而进行的活动。</p>
</li>
<li>
<p>根据产品类型，可以将部署分为三种模式:</p>
<p>1.自定义安装模式</p>
<p>2.现场支持模式</p>
<p>3.Internet模式</p>
</li>
<li>
<p>部署单元：由一个工作版本（可执行构件集）、文档（最终用户支持材料和发布说明）和安装工件组成。</p>
</li>
<li>
<p>部署计划：说明如何将产品从开发商转移到用户群。指定兼容、转换和迁移策略、部署时间表、部署顺序，并需要进行用户培训。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>主要包含三点：</p>
<ul>
<li>
<p>用户的应用环境和项目团队的开发环境往往不同，需要进行调试、磨合。</p>
</li>
<li>
<p>数据或程序迁移。</p>
</li>
<li>
<p>培训服务和使用支持。</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>主要在后期，早期及中期因为需要做部署计划所以也会有。</p>
</li>
<li>
<p>Who</p>
<p>主要包括部署工程师、部署员、文档编写员、包装员、实施员、项目经理、SQA人员和财务人员等。</p>
</li>
<li>
<p>Where</p>
<p>一部分工作可以在开发现场进行，如制定部署计划、包装产品、编写相关文档等；另一部分工作必须在用户现场进行，如β测试、验收测试和用户正式使用中的安装、培训工作等。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://geniusmiaozz.github.io/post-images/1583338192371.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[30天自制操作系统-OSCodeFile学习笔记(1-7天内容)]]></title>
        <id>https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/</id>
        <link href="https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/">
        </link>
        <updated>2020-02-25T07:53:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关键概念">关键概念</h2>
<ul>
<li>
<p>保存在磁盘上的操作系统主要分为启动区和程序区，每个区有自己的代码文件及引用的辅助文件（如字体数据、图片等）。主要系统文件通过Makefile文件链接在一起，构成操作系统。</p>
</li>
<li>
<p>一个操作系统其实就是许多二进制数组成的映像文件，一个二进制数可以理解为一个电信号。</p>
</li>
<li>
<p>在整个操作系统中，全局描述符表GDT只有一张（一个CPU对应一个GDT）。GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此积存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。</p>
</li>
<li>
<p>如何令操作系统对鼠标与键盘这些外设的活动做出响应？首先要对GDT、IDT初始化，即将数据排列在内存的某个地方，然后将这个地方在内存中的位置的起始地址和有效设定个数写入GDTR/IDTR寄存器；然后PIC进行初始化，使CPU能够接受来自不同地方的中断信号；然后完成鼠标和键盘在IDT中的注册，如果鼠标键盘进行操作发生了中断，CPU会自动调用中断函数进行处理。</p>
</li>
</ul>
<h2 id="代码说明">代码说明</h2>
<h3 id="1makefile文件">1.Makefile文件</h3>
<ul>
<li>
<p>DAY_2：创建基础的Makefile文件，包含最基本的制作英雄、汇编、模拟运行、安装至软盘及相关清楚操作。</p>
</li>
<li>
<p>DAY_3：由于拆分了程序区文件，按照高级语言翻译到机器语言的规则（相关见书P60）修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_4：由于新增了OSASK字体信息文件，按照规则修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_6：分隔了Makefile文件，合并了对于后缀名相同、前缀名不同的文件的操作规则，优化代码;：由于新增了程序区文件，按照规则修改了文件，</p>
</li>
</ul>
<h3 id="2启动区代码">2.启动区代码</h3>
<blockquote>
<p><em>0x7c00-0x7dff为规定的启动区内容装载地址。(书P40)</em></p>
<ul>
<li>
<p>DAY_3</p>
<p>创建ipl10.nas，当前的整个启动区代码文件。</p>
</li>
</ul>
</blockquote>
<h4 id="ipl10nas">ipl10.nas</h4>
<ul>
<li>
<p>DAY_3：读盘，按扇区读依次读入每一个扇区（共计10个扇区），同时完成读入过程中的纠错工作。</p>
<p>启动区读盘完毕后JMP至0xc200号地址处。</p>
</li>
</ul>
<h3 id="3程序区代码">3.程序区代码</h3>
<blockquote>
<p><em>向一个空软盘保存文件时，文件的内容会写在磁盘上0x4200以后的地方。</em></p>
<p><em>磁盘上的内容装载到程序0x8000号地址，所以程序位于内存0x8000+0x4200=0xc200号地址。</em></p>
<p><em><strong>此处包含辅助文件，为了完成操作系统无需编写直接引用的文件。编写的文件标注为创建，引用的文件标注为添加。</strong></em></p>
<p><em><strong>删除线意为此项功能在实际项目中已经完成过，但在后续编写中删掉了该功能或在其基础上对其升级，完成了更高级的功能。</strong></em></p>
<ul>
<li>
<p>DAY_3</p>
<p>创建asmhead.nas，程序区代码的前半部分。</p>
<p>创建bookpack.c，程序区代码的后半部分。</p>
<p>创建naskfunc.nas，汇编完成的部分功能函数。</p>
</li>
<li>
<p>DAY_4</p>
<p>修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_5</p>
<p>添加hankaku.txt文件，OSASK字体信息文件。</p>
<p>修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_6</p>
<p>拆分bootpack.c为三个子文件：</p>
<p>创建graphic.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建dsctbl.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建新的bootpack.c，包含程序区代码的后半部分的主函数。</p>
<p>创建bootpack.h，将函数声明、变量生命、宏定义、头文件引用放置在.h头文件中，优化代码。</p>
<p>创建int.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>修改naskfunc.nas。</p>
</li>
<li>
<p>DAY_7</p>
<p>创建fifo.c，包含自制FIFO缓冲区主要功能函数。</p>
<p>修改int.c。</p>
</li>
</ul>
</blockquote>
<h4 id="asmheadnas">asmhead.nas</h4>
<ul>
<li>
<p>DAY_3：设定好程序被装载到内存的位置，即ORG 0xc200，完成与启动区的链接。</p>
<p>新增的代码主要为与CPU有关的设定，此处尚未讲解。</p>
</li>
<li>
<p>DAY_4：设定启动区、颜色数目的信息、颜色位数、分辨率的X和Y、图形缓冲区的开始地址， 即完成设置画面模式并把画面模式的信息保存至内存，并用BIOS取得键盘上各种LED指示灯的状态。</p>
</li>
</ul>
<h4 id="naskfuncnas">naskfunc.nas</h4>
<ul>
<li>
<p>DAY_3：利用汇编完成实现暂停CPU功能的函数。</p>
</li>
<li>
<p>DAY_4：利用汇编完成部分函数，并与C函数链接。主要包含：</p>
<p>1.实现不同字节大小的内存写入。</p>
<p>2.中断标志的置位、复位。</p>
<p>3.中断标志位的压栈保存、弹栈读取。</p>
</li>
<li>
<p>DAY_5：利用汇编完成实现对GDTR、IDTR寄存器加载数据的函数。</p>
<p>GDTR与IDTR结构体基本一样。需要取第一个32位数据的低16位和第二个32位数据，合并作为一个48位数据存入寄存器。</p>
<p>MOV		AX,[ESP+6]      取第一个32位数据低16位数据地址<br>
MOV		[ESP+6],AX      第一个32位数据高16位的地址存入其低16位数据<br>
LGDT	[ESP+6]         第一个32位数高16位的地址开始的输入加载至寄存器</p>
</li>
<li>
<p>DAY_6：利用汇编完成中断处理完成之后的“返回”功能，<em><strong>C中的“return”相当于“RET”，此处需要“IRETD”的功能，故采用汇编实现，详见书P120。</strong></em></p>
</li>
</ul>
<h4 id="bookpackc">bookpack.c</h4>
<ul>
<li>
<p>DAY_3：无限调用汇编实现的暂停CPU功能函数，完成一个最基本的操作系统。</p>
</li>
<li>
<p>DAY_4：利用C完成部分函数，并与汇编函数链接。主要包含：</p>
<p>1.实现内存写入，指针实现。</p>
<p><s>2.利用内存写入实现条纹图案。</s></p>
<p><s>3.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</s></p>
<p><s>4.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</s></p>
</li>
<li>
<p>DAY_5：主要完善的功能：</p>
<p><s>1.利用指针保存画面模式信息的值，这些值应与asmhead.nas保持一致。</s></p>
<p>2.利用结构体保存画面模式信息的值，优化代码。</p>
<p>3.利用箭头记号直接获取结构体中成员的值，优化代码。</p>
<p><s>4.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。此处的函数原型：</s></p>
<blockquote>
<p>void putfont8(char *vram, int xsize, int x, int y, char c, char *font);</p>
<p>其中vram是图形缓冲区的开始地址，xsize是分辨率的X，x是绘制图形最左侧的X坐标，y是绘制图形最顶部的Y坐标，c是绘制的颜色，font是绘制图形的数据信息。</p>
</blockquote>
<p><s>5.利用像素点阵的方法，通过对字符数组的遍历，依次绘制每一个字符的图形，从而完成对整个字符串各字符图形的绘制。</s></p>
<p><s>6.利用像素点阵的方法和sprintf函数，以绘制图形的方式输出一个变量及其数值，有助于debug。</s></p>
<p><s>7.利用像素点阵的方法，完成一个鼠标指针图形的绘制。主要过程为：</s></p>
<blockquote>
<p>首先利用init_mouse_cursor8(char *mouse, char bc)，将鼠标图形的像素点颜色信息存入mouse开头的地址中（bc为背景色）。</p>
<p>然后利用void putblock8_8(char *vram, int vxsize, int pxsize,int pysize, int px0, int py0, char *buf, int bxsize)，vram和vxsize是关于VRAM的信息，pxsize和pysize是绘制图形的大小，px0和py0分别是图形左边的X坐标和图形右边的Y坐标，buf是待绘制图形的存放地址，bxsize是待绘制图像分辨率的X即每一行含有的像素数。</p>
</blockquote>
<p><s>8.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</s></p>
</li>
<li>
<p>DAY_6：主要完善的功能：</p>
<p><em><strong>1.只保留主函数中对各功能的调用、变量及函数的生命，其余功能函数的具体实现分隔为两个文件graphic.c和dsctbl.c。</strong></em></p>
<p>2.修改了PIC的IMR，以便接受来自键盘和鼠标的中断。</p>
</li>
<li>
<p>DAY_7：主要完善的功能：</p>
<p>1.完成等待并检测键盘控制电路准备完毕的功能。</p>
<p>2.完成初始化键盘控制电路的功能。</p>
<p>3.完成激活鼠标的功能。</p>
<p>4.完成从鼠标获取数据的功能，如果二者缓冲区都为空，则执行HLT；如果有任一缓冲区不为空，则优先取键盘缓冲区数据出来显示。</p>
</li>
</ul>
<h4 id="hankakutxt">hankaku.txt</h4>
<ul>
<li>DAY_5：引入的辅助文件，为OSASK字体数据文件。</li>
</ul>
<h4 id="graphicc">graphic.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</p>
<p>2.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</p>
<p>3.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。</p>
<p>4.利用像素点阵的方法，完成一个鼠标指针图形的绘制。</p>
</li>
</ul>
<h4 id="dsctblc">dsctbl.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</p>
<p>2.完成鼠标和键盘中断处理程序在IDT中的注册，即对段地址、段上限、段属性信息的赋值。</p>
</li>
</ul>
<h4 id="intc">int.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.通过对不同端口的赋值来对PIC（可编程中断控制器）进行初始化，<em><strong>此处相较不易理解，详见书P117。</strong></em></p>
<p>2.利用C和汇编完成处理鼠标（IRQ12）和键盘（IRQ1）的中断，即中断发生时需要调用的程序。<em><strong>此处还需要处理IRQ7的中断处理程序，详见书P119。</strong></em></p>
<p><s>3.实现键盘按键发生中断时输出提示信息。</s></p>
</li>
<li>
<p>DAY_7：主要完善的功能：</p>
<p>1.实现多次执行键盘中断的功能。即在一次IRQ1中断发生后，使PIC继续监视IRQ1中断是否发生</p>
<p>2.实现在发生键盘中断时，输出按键编码的功能（从编号为0x0060的设备输入的8位信息是按键编码）。</p>
<p><s>3.利用移送数据实现FIFO（先进先出）缓冲区，能够输出正确的按键编码，避免两个字节的键码值被丢掉后一个。</s></p>
<p><s>4.利用读追赶写的方式实现FIFO缓冲区，当读写至末尾时进行归0处理，避免了数据的移送操作，优化性能。</s></p>
<p>4.完成处理鼠标中断的功能，<em><strong>分别通知从PIC中断IRQ12已完成和主PIC中断IRQ2已完成，书P142。</strong></em></p>
</li>
</ul>
<h4 id="fifoc">fifo.c</h4>
<ul>
<li>
<p>DAY_7：</p>
<p>1.为FIFO缓冲区增加首地址、下一个数据写入地址、写一个数据读出地址、缓冲区总字节数、缓冲区里没有数据的字节数、缓冲区是否溢出的表示结构体信息。</p>
<p>2.完成初始化FIFO缓冲区的功能。</p>
<p>3.完成向FIFO缓冲区传送数据并保存的功能。</p>
<p>4.完成从FIFO缓冲区获得一个字节数据的功能。</p>
<p>5.完成查看当前FIFO缓冲区存放了多少有效数据的功能。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome here!]]></title>
        <id>https://geniusmiaozz.github.io/post/about/</id>
        <link href="https://geniusmiaozz.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关于本站">🏠 关于本站</h2>
<p>知 无 不 言</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>99年，天津人，性别男，爱好女。</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>游戏，音乐，电影，电子竞技，心理学，哲学</p>
<h2 id="联系方式">📬 联系方式</h2>
<p>QQ:1208520869<br>
WeChat:miaomiao132465798<br>
邮箱:miaozijianzz@outlook.com</p>
]]></content>
    </entry>
</feed>