<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geniusmiaozz.github.io</id>
    <title>GeniusMiao&apos;s blog.</title>
    <updated>2020-03-08T08:43:26.206Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geniusmiaozz.github.io"/>
    <link rel="self" href="https://geniusmiaozz.github.io/atom.xml"/>
    <subtitle>醉梦不知天在水，满船新梦压清河。</subtitle>
    <logo>https://geniusmiaozz.github.io/images/avatar.png</logo>
    <icon>https://geniusmiaozz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, GeniusMiao&apos;s blog.</rights>
    <entry>
        <title type="html"><![CDATA[硬 件 工 程(DAY_1)]]></title>
        <id>https://geniusmiaozz.github.io/post/ying-jian-gong-cheng-day_1/</id>
        <link href="https://geniusmiaozz.github.io/post/ying-jian-gong-cheng-day_1/">
        </link>
        <updated>2020-03-07T09:58:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="硬-件-工-程day_1">硬 件 工 程(DAY_1)</h1>
<h2 id="导语">导语</h2>
<p>近日学习软件工程这一课程，对于这方面的知识如软件开发过程、开发模型均有了一定的理解。今天看到一个小故事，大概介么个意思：</p>
<blockquote>
<p>话说有一登山爱好者甲，某一天慕名而来挑战登山。这哥们在山脚下为了登山可是煞费苦心，先围绕山脚下转一整圈，又是打量山势又是观察主峰与山包，然后设计出了多种登山计划，又分析得到一个首选计划，同时安排好备用计划，一切安排妥当没问题后终于开始了登山行动。</p>
</blockquote>
<blockquote>
<p>又话说还有个登山爱好者乙，这天碰巧了也来登这座山。刚到这看见A正在那勘察情况，那是二话没说就直接上山寻路了。不久便发现走到了一个没有前路的小山包上，不过并没有气馁，稍作观察之后就调头向另一个更高的山峰出发。就这样B在不断的下与上的过程中很快将A远远的甩在后面。</p>
</blockquote>
<blockquote>
<p>当A终于登上山顶之后，发现B已经整理好准备下山了。B这时候帅(qian)气(zou)地送给A一句话：“这，就是极限编程的厉害！”</p>
</blockquote>
<p>好家伙，学到了！（脑子：我会了。手：你不会。）不过，手会的机会随之就到来了。。</p>
<h2 id="需求伊始">需求伊始</h2>
<p>自打这次寒假放假回家，之前家里那把大号仿真Gun玩具我就一直没找到。</p>
<p>前两天物美超市做活动100块钱三箱伊利金典纯牛奶剁了波手，现在看着箱里形状各异的硬纸板突然有了想法：既然仿真Gun找不到了，那我不如重拾老本行DIY一把？正好应用一下最近刚刚学到的“极限编程”，这次我也不先指定什么计划，想到什么做什么，体验一次试试？说干就干！</p>
<p>首先是一波简单的原材料及工具的清点：</p>
<p><img src="https://geniusmiaozz.github.io/post-images/1583577325093.jpg" alt="" loading="lazy"><br>
<img src="https://geniusmiaozz.github.io/post-images/1583577328676.jpg" alt="" loading="lazy"></p>
<p>从哪开始呢。。？就先来设计一个箭头型的Gun口吧！</p>
<figure data-type="image" tabindex="1"><img src="https://geniusmiaozz.github.io/post-images/1583577383150.jpg" alt="" loading="lazy"></figure>
<p>考虑到硬纸板不支持咱整体都做的立体饱满，必须得先考虑一下如何进行Gun口和Gun身的连接问题，直接采用“三板夹二板”固定的方法。同时如果箭头合并之后再在内部粘东西就较为棘手了， 必须先进行半个箭头和连接部件的粘连。下图可以体现出这两点：</p>
<figure data-type="image" tabindex="2"><img src="https://geniusmiaozz.github.io/post-images/1583577531479.jpg" alt="" loading="lazy"></figure>
<p>进行半个箭头和头身连接部件的粘连：</p>
<figure data-type="image" tabindex="3"><img src="https://geniusmiaozz.github.io/post-images/1583577892045.jpg" alt="" loading="lazy"></figure>
<p>初步完成的两个半箭头就如下图了：</p>
<figure data-type="image" tabindex="4"><img src="https://geniusmiaozz.github.io/post-images/1583577951084.jpg" alt="" loading="lazy"></figure>
<p>嗯。。此时可以完成两个半箭头的合并了，再给连接部件加个延长部件方便连接，下图就是初步完成的Gun口了：</p>
<figure data-type="image" tabindex="5"><img src="https://geniusmiaozz.github.io/post-images/1583578392505.jpg" alt="" loading="lazy"></figure>
<p>现在开始做Gun身吧。继续采用经典的“二板夹一板——骨折夹板”固定方法，即在两个硬纸板的连接处帮上另一根硬纸板，用来达到防止弯曲的效果，下图为简单的原理图：</p>
<figure data-type="image" tabindex="6"><img src="https://geniusmiaozz.github.io/post-images/1583578538127.jpg" alt="" loading="lazy"></figure>
<p>正式开始制作！先进行简单的固定方便处理：</p>
<figure data-type="image" tabindex="7"><img src="https://geniusmiaozz.github.io/post-images/1583578574382.jpg" alt="" loading="lazy"></figure>
<p>此时我有了新的想法：为了看起来炫酷也为了后续的扩展，此处采用两个直角梯形合并作为“二板夹一板”中被夹的“一板”，效果图如下：</p>
<figure data-type="image" tabindex="8"><img src="https://geniusmiaozz.github.io/post-images/1583578738028.jpg" alt="" loading="lazy"></figure>
<p>再看一个侧面的效果图：</p>
<figure data-type="image" tabindex="9"><img src="https://geniusmiaozz.github.io/post-images/1583578766933.jpg" alt="" loading="lazy"></figure>
<p>应该没啥问题了。现在来做个Gun托吧，Gun托可以做个饱满的。</p>
<p>Gun托的平面图：</p>
<figure data-type="image" tabindex="10"><img src="https://geniusmiaozz.github.io/post-images/1583578820451.jpg" alt="" loading="lazy"></figure>
<p>什么？你说你看不出来这是个Gun托？折叠起来你再看看？</p>
<figure data-type="image" tabindex="11"><img src="https://geniusmiaozz.github.io/post-images/1583578866627.jpg" alt="" loading="lazy"></figure>
<p>接下来。。就把三者连接在一起吧。（此处参考了原型模型中的可以很快见到开发成果）</p>
<figure data-type="image" tabindex="12"><img src="https://geniusmiaozz.github.io/post-images/1583578961474.jpg" alt="" loading="lazy"></figure>
<p>目前主要的Gun身还是太不稳定了，我们给两边各自加厚一层：</p>
<figure data-type="image" tabindex="13"><img src="https://geniusmiaozz.github.io/post-images/1583579018517.jpg" alt="" loading="lazy"></figure>
<p>注意后面Gun托的连接部件宽度是小于Gun身宽度的！为了确保更好的效果双面胶要靠边上粘：</p>
<figure data-type="image" tabindex="14"><img src="https://geniusmiaozz.github.io/post-images/1583579069164.jpg" alt="" loading="lazy"></figure>
<p>加固完成之后初步的主体就完成啦！</p>
<figure data-type="image" tabindex="15"><img src="https://geniusmiaozz.github.io/post-images/1583579076996.jpg" alt="" loading="lazy"></figure>
<p>嗯。。必需功能还缺一个把手，其他辅助功能如瞄准之类的后续再看。今天就到这了，明天继续！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你见过这样的代码吗？]]></title>
        <id>https://geniusmiaozz.github.io/post/ni-jian-guo-zhe-yang-de-dai-ma-ma/</id>
        <link href="https://geniusmiaozz.github.io/post/ni-jian-guo-zhe-yang-de-dai-ma-ma/">
        </link>
        <updated>2020-03-07T09:47:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="长见识了">长见识了..</h1>
<p>前两天刷知乎时看到这样一行代码：</p>
<p><strong>char *(*c[10])(int **p);</strong></p>
<p>当时我的大脑中是这样的：</p>
<figure data-type="image" tabindex="1"><img src="https://geniusmiaozz.github.io/post-images/1583574662322.png" alt="" loading="lazy"></figure>
<p>随之我的大脑中是这样的：</p>
<p>*c[10]我记得是一个指针数组，数组中的元素为指针；后面括号中的内容只能是参数了，参数为一个int类型的二重指针？那前面的char *呢。。</p>
<p>上网求解之后我的大脑又变成了这样的：</p>
<figure data-type="image" tabindex="2"><img src="https://geniusmiaozz.github.io/post-images/1583574683219.jpg" alt="" loading="lazy"></figure>
<hr>
<p>题解+个人总结：</p>
<ul>
<li>
<p>首先，c[10]是一个数组。</p>
</li>
<li>
<p>在前面加上一个*，*c[10]是一个指针数组，数组中元素的类型为指针；如果是(*c)[10]，则为一个数组指针，c这个指针指向一个元素个数为10的数组的首地址。</p>
</li>
<li>
<p>紧接着，由于加上了参数，(*c[10])(int **p)是一个函数指针的数组，函数有一个int **p二重指针作为形参。</p>
</li>
<li>
<p>最后，char *(*c[10])(int **p)代表：c是一个数组，该数组用于存放一个形参为整型二重指针、返回值为字符串的函数的函数指针。</p>
</li>
</ul>
<p>再附上一段网上给出的代码：</p>
<pre><code class="language-c++">char *(*c[10])(int **p);
char *fun(int **p)
{
    return &quot;hello\n&quot;;
}
int main()
{
	c[0] = fun;
	printf(&quot;%s&quot;, c[0](NULL));
	return 0;
}
</code></pre>
<p>亲测的运行结果：<img src="https://geniusmiaozz.github.io/post-images/1583574463792.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是软件过程？]]></title>
        <id>https://geniusmiaozz.github.io/post/ruan-jian-gong-cheng-zhong-guo-cheng-de-gai-nian/</id>
        <link href="https://geniusmiaozz.github.io/post/ruan-jian-gong-cheng-zhong-guo-cheng-de-gai-nian/">
        </link>
        <updated>2020-03-04T16:02:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="软件过程的定义">软件过程的定义</h1>
<p><strong>软件过程由开发或维护软件及其相关产品的一系列活动构成，这些活动从不同的方面定义了软件开发中的步骤、交付物、涉众及其职责等流程要素。</strong></p>
<h1 id="为什么要引入软件过程">为什么要引入软件过程？</h1>
<ul>
<li>
<p>软件工作的范围从只考虑编写程序扩展到需要考虑整个软件生存周期。</p>
</li>
<li>
<p>软件的开发风险从曾经的少、可预知、可控制演变到多、不易预知、不易控制。</p>
</li>
<li>
<p>软件开发的角色从程序员扩展到需要团队中更多的角色。</p>
</li>
<li>
<p>软件标准从软件产品的标准化扩展到软件开发过程的标准化。</p>
</li>
</ul>
<h1 id="软件过程的实现">软件过程的实现</h1>
<p><strong>一个软件的生命周期分为软件定义、软件开发、软件维护三个周期，整个过程包含基本活动及辅助性活动。软件过程通过三个“IN”：输入，如需求；资源，如人力、工具；控制，如预算、时间表、规范标准，最终完成一个“OUT”如程序代码、程序文档。</strong></p>
<h1 id="活动的概念">活动的概念</h1>
<ul>
<li>
<p>基础活动</p>
<p>主要包含问题定义，需求，规约，设计，实现，软件验证，集成，软件演进/维护，退役等。</p>
</li>
<li>
<p>辅助性活动</p>
<p>软件项目跟踪和控制，正式的技术复审，软件质量保证，软件配置管理，文档编制，服用管理，度量，风险管理等。</p>
</li>
</ul>
<h1 id="活动详解">活动详解</h1>
<h2 id="问题定义活动">问题定义活动</h2>
<ul>
<li>
<p>What</p>
<p>定义要解决的问题，并确定系统范围。</p>
</li>
<li>
<p>Why</p>
<p>形成初步的早起判断，达成最初共识。</p>
</li>
<li>
<p>When</p>
<p>在项目日程表的最前端，占整个开发时间中的比例很小。</p>
</li>
<li>
<p>Who</p>
<p>由系统分析师、出资方领导、出资方技术人员、开发方领导和项目经理定义。</p>
</li>
<li>
<p>Where</p>
<p>客户现场。</p>
</li>
<li>
<p>How<br>
<img src="https://geniusmiaozz.github.io/post-images/1583337862318.jpg" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="可行性研究活动">可行性研究活动</h2>
<ul>
<li>
<p>What</p>
<p>以相对短的时间和相对低的成本来确定给定的问题在其约束条件内是否有解、有几种解以及哪个是最佳解。</p>
</li>
<li>
<p>Why</p>
<p>确立满足约束条件的方案是否存在、是否可行、是否最优，然后才能在最优方案的基础上进行开发、</p>
</li>
<li>
<p>When</p>
<p>在项目的早期阶段，占整个开发时间中的比例较小。</p>
</li>
<li>
<p>Who</p>
<p>由系统分析师、出资方领导、出资方技术人员、开发方领导、项目经理、架构设计师、市场人员、软件质量保证人员等研究。</p>
</li>
<li>
<p>Where</p>
<p>客户现场。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://geniusmiaozz.github.io/post-images/1583338118988.jpg" alt="" loading="lazy"></figure>
<h2 id="需求分析活动">需求分析活动</h2>
<ul>
<li>
<p>What</p>
<p>通过五点来描述：</p>
<ul>
<li>
<p>需求：主要是在产品构建之前确定的系统必须符合的条件或具备的功能，它们是关于系统将要完成什么工作的一段描述语句，它们必须经过所有相关人员的认可，其目的是彻底地解决客户的问题。</p>
</li>
<li>
<p>需求文档：一组需求的集合，分为用户需求文档、系统需求文档和软件规约文档</p>
</li>
<li>
<p>功能性需求：描述了系统应该做什么，即具备的功能或服务。（输入、输出和计算等）</p>
</li>
<li>
<p>非功能性需求：描述了系统必须遵守的约束条件。（响应时间、吞吐量、可靠性、可移植性、可扩展性、易用性、安全性、资源要求、可复 用性、技术要求、文化和政策需求、法律需求、道德要求、隐私要求，等等）</p>
</li>
<li>
<p>描述需求的标准：是完整的、正确的、必要的、无歧义的、可行的、可验证的以及被设置了优先级别的。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>六个错误：</p>
<ul>
<li>
<p>需求不一致、模糊、矛盾</p>
</li>
<li>
<p>需求变更</p>
</li>
<li>
<p>客户忽略领域常识/知识/术语</p>
</li>
<li>
<p>客户集中于现有系统的不足之处，而忽略了系统要实现的关键功能</p>
</li>
<li>
<p>零碎、无组织、不明确、表达不清</p>
</li>
<li>
<p>不分轻重缓急</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>贯穿于整个软件开发过程，早起工作量大后逐渐减少。</p>
</li>
<li>
<p>Who</p>
<p>系统分析师、需求阐释者、客户代表、用户代表、开发方领导、项目经理、架构设计师、领域专家、财务人员、市场人员、软件质量保证（SQA，Software Quality Assure）人员、程序员、测试人员、部署人员、技术文档编写人员、培训人员等。</p>
</li>
<li>
<p>Where</p>
<p>三种情况：</p>
<ul>
<li>
<p>调研时，在客户现场</p>
</li>
<li>
<p>编纂软件需求规约文档时，可以在开发单位</p>
</li>
<li>
<p>复审相关的需求文档时，根据需要来安排</p>
</li>
</ul>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://geniusmiaozz.github.io/post-images/1583338131488.jpg" alt="" loading="lazy"></figure>
<h2 id="设计活动">设计活动</h2>
<ul>
<li>
<p>What</p>
<p>通过四个方面来描述：</p>
<ul>
<li>
<p>设计：是在系统的约束条件下（如预算、时间、人力资源、用户软、硬件环境和用户对系统的操作能力等），为了实现系统的功能性需求和非功能性需求，而找到并描述的一种遵循高质量的通用原则的方法，其交付文档能够指导开发人员实现系统。</p>
</li>
<li>
<p>总体设计：任务是根据软件需求规约文档，确定一个合理的软件体系结构。这个体系结构包括合理地划分组成系统的模块、模块间的调用关系以及模块间的接口关系。软件体系结构还从总体方面决定了系统的可扩充性、可维护性，以及系统的性能等。总体设计的设计粒度较大，有时也被称为概要设计、架构设计。</p>
</li>
<li>
<p>详细设计：详细设计地任务是在总体设计的基础上进一步确定如何实现目标系统，包括系统的数据对象的设计、人机接口的设计以及模块逻辑的详细设计。</p>
</li>
<li>
<p>设计部件的粒度：系统、子系统、框架、构件、组件、模块、类、 方法等。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>主要包含：</p>
<ul>
<li>
<p>软件架构是软件系统的核心</p>
</li>
<li>
<p>应对复杂多变的情况，同时保持完整性</p>
</li>
<li>
<p>应对系统在扩展功能当中出现的问题</p>
</li>
<li>
<p>大规模复用的有效基础</p>
</li>
<li>
<p>项目管理的基础</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>贯穿于整个软件开发过程的设计活动。</p>
</li>
<li>
<p>Who</p>
<p>主要包括架构设计师、软件设计员、复用工 程师、设计复审员、项目经理、财务人员、 软件质量保证（SQA，Software Quality Assure）人员和需求变更者等。</p>
</li>
<li>
<p>Where</p>
<p>建议在软件企业内部进行设计。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://geniusmiaozz.github.io/post-images/1583338157712.jpg" alt="" loading="lazy"></figure>
<h2 id="实施活动">实施活动</h2>
<ul>
<li>
<p>What</p>
<p>三个方面：</p>
<ul>
<li>
<p>编码：是将软件设计结果转换成用某种程序设计语言书写的程序。</p>
</li>
<li>
<p>单元测试：是把一个模块作为独立的程序单元进行测试，以保证它能够正确执行规定的功能。</p>
</li>
<li>
<p>集成：是指将单独的软件构件合并成一个整体的软件系统。集成分为集成子系统和集成系统两个级别。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>两个极端：</p>
<ul>
<li>以实施为中心的软件开发</li>
</ul>
<p>弱化的需求，弱化的设计。对实施人员的过度依赖。</p>
<ul>
<li>对实施活动的轻视</li>
</ul>
<p>需要的时间进入工作状态，具有技术含量，水平存在差异，实施质量不易度量</p>
</li>
<li>
<p>When</p>
<p>项目的中、后期阶段。</p>
</li>
<li>
<p>Who</p>
<p>包括实施员、代码复审员、集成员、测试工程师、测试员、项目经理、架构设计师、软件设计员、复用工程师、SQA人员和财务人员等</p>
</li>
<li>
<p>Where</p>
<p>建议在软件企业内部进行开发。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://geniusmiaozz.github.io/post-images/1583338166171.jpg" alt="" loading="lazy"></figure>
<h2 id="测试活动">测试活动</h2>
<ul>
<li>
<p>What</p>
<p>通过七个方面来描述：</p>
<ul>
<li>
<p>测试：是选择适当的测试用例执行被测程序的过程，其目的在于发现程序错误。</p>
</li>
<li>
<p>缺陷：是系统任一方面（包括需求、设计或代码）的缺点。该缺点会促成或潜在的促成一个或多个失败发生。</p>
</li>
<li>
<p>错误：是指程序中的缺陷所产生的不正确结果。</p>
</li>
<li>
<p>失败：当一个程序不能运行或者其表现不可被接受时称为失败。失败是系统执行中出现的情况。失败源于代码 缺陷。</p>
</li>
<li>
<p>主要包含6种测试活动：单元测试、集成测试、系统测试、α测试、β测试、验收测试。</p>
</li>
<li>
<p>质量维度：描述质量的概念或评测质量的方法的不同视角。</p>
</li>
<li>
<p>测试用例：为特定目标开发的测试输入、执行条件和预期结果的集合。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>三方面：</p>
<ul>
<li>
<p>及时检查出项目中的缺陷和不足。</p>
</li>
<li>
<p>保证所开发的软件能够达到用户满意。</p>
</li>
<li>
<p>测试是项目管理的重要内容。</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>贯穿于软件整个生命周期中。</p>
</li>
<li>
<p>Who</p>
<p>主要包括测试工程师、测试员、软件设计员、实施员、项目经理、部署工程师、部署员、SQA人员和财务人员等。</p>
</li>
<li>
<p>Where</p>
<p>建议单元测试、集成测试和系统测试在实施员所在的开发现场及其附近进行，β测试和验收测试则完全在用户现场测试。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://geniusmiaozz.github.io/post-images/1583338176023.jpg" alt="" loading="lazy"></figure>
<h2 id="部署活动">部署活动</h2>
<ul>
<li>
<p>What</p>
<p>通过四个方面来描述：</p>
<ul>
<li>
<p>部署：是为确保最终用户可以正常使用软件产品而进行的活动。</p>
</li>
<li>
<p>根据产品类型，可以将部署分为三种模式:</p>
<p>1.自定义安装模式</p>
<p>2.现场支持模式</p>
<p>3.Internet模式</p>
</li>
<li>
<p>部署单元：由一个工作版本（可执行构件集）、文档（最终用户支持材料和发布说明）和安装工件组成。</p>
</li>
<li>
<p>部署计划：说明如何将产品从开发商转移到用户群。指定兼容、转换和迁移策略、部署时间表、部署顺序，并需要进行用户培训。</p>
</li>
</ul>
</li>
<li>
<p>Why</p>
<p>主要包含三点：</p>
<ul>
<li>
<p>用户的应用环境和项目团队的开发环境往往不同，需要进行调试、磨合。</p>
</li>
<li>
<p>数据或程序迁移。</p>
</li>
<li>
<p>培训服务和使用支持。</p>
</li>
</ul>
</li>
<li>
<p>When</p>
<p>主要在后期，早期及中期因为需要做部署计划所以也会有。</p>
</li>
<li>
<p>Who</p>
<p>主要包括部署工程师、部署员、文档编写员、包装员、实施员、项目经理、SQA人员和财务人员等。</p>
</li>
<li>
<p>Where</p>
<p>一部分工作可以在开发现场进行，如制定部署计划、包装产品、编写相关文档等；另一部分工作必须在用户现场进行，如β测试、验收测试和用户正式使用中的安装、培训工作等。</p>
</li>
<li>
<p>How</p>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://geniusmiaozz.github.io/post-images/1583338192371.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[30天自制操作系统-OSCodeFile学习笔记(1-7天内容)]]></title>
        <id>https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/</id>
        <link href="https://geniusmiaozz.github.io/post/geniusmiao-os-ge-dai-ma-wen-jian-jian-yao-shuo-ming/">
        </link>
        <updated>2020-02-25T07:53:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关键概念">关键概念</h2>
<ul>
<li>
<p>保存在磁盘上的操作系统主要分为启动区和程序区，每个区有自己的代码文件及引用的辅助文件（如字体数据、图片等）。主要系统文件通过Makefile文件链接在一起，构成操作系统。</p>
</li>
<li>
<p>一个操作系统其实就是许多二进制数组成的映像文件，一个二进制数可以理解为一个电信号。</p>
</li>
<li>
<p>在整个操作系统中，全局描述符表GDT只有一张（一个CPU对应一个GDT）。GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此积存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。</p>
</li>
<li>
<p>如何令操作系统对鼠标与键盘这些外设的活动做出响应？首先要对GDT、IDT初始化，即将数据排列在内存的某个地方，然后将这个地方在内存中的位置的起始地址和有效设定个数写入GDTR/IDTR寄存器；然后PIC进行初始化，使CPU能够接受来自不同地方的中断信号；然后完成鼠标和键盘在IDT中的注册，如果鼠标键盘进行操作发生了中断，CPU会自动调用中断函数进行处理。</p>
</li>
</ul>
<h2 id="代码说明">代码说明</h2>
<h3 id="1makefile文件">1.Makefile文件</h3>
<ul>
<li>
<p>DAY_2：创建基础的Makefile文件，包含最基本的制作英雄、汇编、模拟运行、安装至软盘及相关清楚操作。</p>
</li>
<li>
<p>DAY_3：由于拆分了程序区文件，按照高级语言翻译到机器语言的规则（相关见书P60）修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_4：由于新增了OSASK字体信息文件，按照规则修改了文件，且对于需要使用的关键路径及关键文件进行了定义，优化代码。</p>
</li>
<li>
<p>DAY_6：分隔了Makefile文件，合并了对于后缀名相同、前缀名不同的文件的操作规则，优化代码;：由于新增了程序区文件，按照规则修改了文件，</p>
</li>
</ul>
<h3 id="2启动区代码">2.启动区代码</h3>
<blockquote>
<p><em>0x7c00-0x7dff为规定的启动区内容装载地址。(书P40)</em></p>
<ul>
<li>
<p>DAY_3</p>
<p>创建ipl10.nas，当前的整个启动区代码文件。</p>
</li>
</ul>
</blockquote>
<h4 id="ipl10nas">ipl10.nas</h4>
<ul>
<li>
<p>DAY_3：读盘，按扇区读依次读入每一个扇区（共计10个扇区），同时完成读入过程中的纠错工作。</p>
<p>启动区读盘完毕后JMP至0xc200号地址处。</p>
</li>
</ul>
<h3 id="3程序区代码">3.程序区代码</h3>
<blockquote>
<p><em>向一个空软盘保存文件时，文件的内容会写在磁盘上0x4200以后的地方。</em></p>
<p><em>磁盘上的内容装载到程序0x8000号地址，所以程序位于内存0x8000+0x4200=0xc200号地址。</em></p>
<p><em><strong>此处包含辅助文件，为了完成操作系统无需编写直接引用的文件。编写的文件标注为创建，引用的文件标注为添加。</strong></em></p>
<p><em><strong>删除线意为此项功能在实际项目中已经完成过，但在后续编写中删掉了该功能或在其基础上对其升级，完成了更高级的功能。</strong></em></p>
<ul>
<li>
<p>DAY_3</p>
<p>创建asmhead.nas，程序区代码的前半部分。</p>
<p>创建bookpack.c，程序区代码的后半部分。</p>
<p>创建naskfunc.nas，汇编完成的部分功能函数。</p>
</li>
<li>
<p>DAY_4</p>
<p>修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_5</p>
<p>添加hankaku.txt文件，OSASK字体信息文件。</p>
<p>修改naskfunc.nas、bookpack.c。</p>
</li>
<li>
<p>DAY_6</p>
<p>拆分bootpack.c为三个子文件：</p>
<p>创建graphic.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建dsctbl.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>创建新的bootpack.c，包含程序区代码的后半部分的主函数。</p>
<p>创建bootpack.h，将函数声明、变量生命、宏定义、头文件引用放置在.h头文件中，优化代码。</p>
<p>创建int.c，包含程序区代码的后半部分的部分功能函数。</p>
<p>修改naskfunc.nas。</p>
</li>
<li>
<p>DAY_7</p>
<p>创建fifo.c，包含自制FIFO缓冲区主要功能函数。</p>
<p>修改int.c。</p>
</li>
</ul>
</blockquote>
<h4 id="asmheadnas">asmhead.nas</h4>
<ul>
<li>
<p>DAY_3：设定好程序被装载到内存的位置，即ORG 0xc200，完成与启动区的链接。</p>
<p>新增的代码主要为与CPU有关的设定，此处尚未讲解。</p>
</li>
<li>
<p>DAY_4：设定启动区、颜色数目的信息、颜色位数、分辨率的X和Y、图形缓冲区的开始地址， 即完成设置画面模式并把画面模式的信息保存至内存，并用BIOS取得键盘上各种LED指示灯的状态。</p>
</li>
</ul>
<h4 id="naskfuncnas">naskfunc.nas</h4>
<ul>
<li>
<p>DAY_3：利用汇编完成实现暂停CPU功能的函数。</p>
</li>
<li>
<p>DAY_4：利用汇编完成部分函数，并与C函数链接。主要包含：</p>
<p>1.实现不同字节大小的内存写入。</p>
<p>2.中断标志的置位、复位。</p>
<p>3.中断标志位的压栈保存、弹栈读取。</p>
</li>
<li>
<p>DAY_5：利用汇编完成实现对GDTR、IDTR寄存器加载数据的函数。</p>
<p>GDTR与IDTR结构体基本一样。需要取第一个32位数据的低16位和第二个32位数据，合并作为一个48位数据存入寄存器。</p>
<p>MOV		AX,[ESP+6]      取第一个32位数据低16位数据地址<br>
MOV		[ESP+6],AX      第一个32位数据高16位的地址存入其低16位数据<br>
LGDT	[ESP+6]         第一个32位数高16位的地址开始的输入加载至寄存器</p>
</li>
<li>
<p>DAY_6：利用汇编完成中断处理完成之后的“返回”功能，<em><strong>C中的“return”相当于“RET”，此处需要“IRETD”的功能，故采用汇编实现，详见书P120。</strong></em></p>
</li>
</ul>
<h4 id="bookpackc">bookpack.c</h4>
<ul>
<li>
<p>DAY_3：无限调用汇编实现的暂停CPU功能函数，完成一个最基本的操作系统。</p>
</li>
<li>
<p>DAY_4：利用C完成部分函数，并与汇编函数链接。主要包含：</p>
<p>1.实现内存写入，指针实现。</p>
<p><s>2.利用内存写入实现条纹图案。</s></p>
<p><s>3.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</s></p>
<p><s>4.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</s></p>
</li>
<li>
<p>DAY_5：主要完善的功能：</p>
<p><s>1.利用指针保存画面模式信息的值，这些值应与asmhead.nas保持一致。</s></p>
<p>2.利用结构体保存画面模式信息的值，优化代码。</p>
<p>3.利用箭头记号直接获取结构体中成员的值，优化代码。</p>
<p><s>4.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。此处的函数原型：</s></p>
<blockquote>
<p>void putfont8(char *vram, int xsize, int x, int y, char c, char *font);</p>
<p>其中vram是图形缓冲区的开始地址，xsize是分辨率的X，x是绘制图形最左侧的X坐标，y是绘制图形最顶部的Y坐标，c是绘制的颜色，font是绘制图形的数据信息。</p>
</blockquote>
<p><s>5.利用像素点阵的方法，通过对字符数组的遍历，依次绘制每一个字符的图形，从而完成对整个字符串各字符图形的绘制。</s></p>
<p><s>6.利用像素点阵的方法和sprintf函数，以绘制图形的方式输出一个变量及其数值，有助于debug。</s></p>
<p><s>7.利用像素点阵的方法，完成一个鼠标指针图形的绘制。主要过程为：</s></p>
<blockquote>
<p>首先利用init_mouse_cursor8(char *mouse, char bc)，将鼠标图形的像素点颜色信息存入mouse开头的地址中（bc为背景色）。</p>
<p>然后利用void putblock8_8(char *vram, int vxsize, int pxsize,int pysize, int px0, int py0, char *buf, int bxsize)，vram和vxsize是关于VRAM的信息，pxsize和pysize是绘制图形的大小，px0和py0分别是图形左边的X坐标和图形右边的Y坐标，buf是待绘制图形的存放地址，bxsize是待绘制图像分辨率的X即每一行含有的像素数。</p>
</blockquote>
<p><s>8.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</s></p>
</li>
<li>
<p>DAY_6：主要完善的功能：</p>
<p><em><strong>1.只保留主函数中对各功能的调用、变量及函数的生命，其余功能函数的具体实现分隔为两个文件graphic.c和dsctbl.c。</strong></em></p>
<p>2.修改了PIC的IMR，以便接受来自键盘和鼠标的中断。</p>
</li>
<li>
<p>DAY_7：主要完善的功能：</p>
<p>1.完成等待并检测键盘控制电路准备完毕的功能。</p>
<p>2.完成初始化键盘控制电路的功能。</p>
<p>3.完成激活鼠标的功能。</p>
<p>4.完成从鼠标获取数据的功能，如果二者缓冲区都为空，则执行HLT；如果有任一缓冲区不为空，则优先取键盘缓冲区数据出来显示。</p>
</li>
</ul>
<h4 id="hankakutxt">hankaku.txt</h4>
<ul>
<li>DAY_5：引入的辅助文件，为OSASK字体数据文件。</li>
</ul>
<h4 id="graphicc">graphic.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.实现色号设定，选择利用到的16种颜色并编号，按照调色板的号码写入步骤（书P80）完成功能。</p>
<p>2.实现绘制矩形的函数，并绘制出一个基本界面及任务条(task bar)。</p>
<p>3.利用像素点阵的方法，即改变内存中若干个像素点的颜色，完成一个字符的显示。</p>
<p>4.利用像素点阵的方法，完成一个鼠标指针图形的绘制。</p>
</li>
</ul>
<h4 id="dsctblc">dsctbl.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.利用类调色板初始化的思路对GDT和TDT进行初步初始化。</p>
<p>2.完成鼠标和键盘中断处理程序在IDT中的注册，即对段地址、段上限、段属性信息的赋值。</p>
</li>
</ul>
<h4 id="intc">int.c</h4>
<ul>
<li>
<p>DAY_6：主要完善的功能：</p>
<p>1.通过对不同端口的赋值来对PIC（可编程中断控制器）进行初始化，<em><strong>此处相较不易理解，详见书P117。</strong></em></p>
<p>2.利用C和汇编完成处理鼠标（IRQ12）和键盘（IRQ1）的中断，即中断发生时需要调用的程序。<em><strong>此处还需要处理IRQ7的中断处理程序，详见书P119。</strong></em></p>
<p><s>3.实现键盘按键发生中断时输出提示信息。</s></p>
</li>
<li>
<p>DAY_7：主要完善的功能：</p>
<p>1.实现多次执行键盘中断的功能。即在一次IRQ1中断发生后，使PIC继续监视IRQ1中断是否发生</p>
<p>2.实现在发生键盘中断时，输出按键编码的功能（从编号为0x0060的设备输入的8位信息是按键编码）。</p>
<p><s>3.利用移送数据实现FIFO（先进先出）缓冲区，能够输出正确的按键编码，避免两个字节的键码值被丢掉后一个。</s></p>
<p><s>4.利用读追赶写的方式实现FIFO缓冲区，当读写至末尾时进行归0处理，避免了数据的移送操作，优化性能。</s></p>
<p>4.完成处理鼠标中断的功能，<em><strong>分别通知从PIC中断IRQ12已完成和主PIC中断IRQ2已完成，书P142。</strong></em></p>
</li>
</ul>
<h4 id="fifoc">fifo.c</h4>
<ul>
<li>
<p>DAY_7：</p>
<p>1.为FIFO缓冲区增加首地址、下一个数据写入地址、写一个数据读出地址、缓冲区总字节数、缓冲区里没有数据的字节数、缓冲区是否溢出的表示结构体信息。</p>
<p>2.完成初始化FIFO缓冲区的功能。</p>
<p>3.完成向FIFO缓冲区传送数据并保存的功能。</p>
<p>4.完成从FIFO缓冲区获得一个字节数据的功能。</p>
<p>5.完成查看当前FIFO缓冲区存放了多少有效数据的功能。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome here!]]></title>
        <id>https://geniusmiaozz.github.io/post/about/</id>
        <link href="https://geniusmiaozz.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关于本站">🏠 关于本站</h2>
<p>知 无 不 言</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>99年，天津人，性别男，爱好女。</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>游戏，音乐，电影，电子竞技，心理学，哲学</p>
<h2 id="联系方式">📬 联系方式</h2>
<p>QQ:1208520869<br>
WeChat:miaomiao132465798<br>
邮箱:miaozijianzz@outlook.com</p>
]]></content>
    </entry>
</feed>